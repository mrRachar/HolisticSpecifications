 
 ERC20~\cite{ERC20} is a widely used token standard which describes the 
 basic functionality expected by any    Ethereum-based token contract. 
 It issues and keeps track of participants' tokens, and supports the  transfer
 of tokens between participants. 


An important question, therefore, is to identify the precise circumstances under which a transfer of tokens may take place.
The answer is that transfer of tokens 
 can only take place only provided that  there were sufficient tokens in the
 owner's account, and that
 the transfer was instigated by the owner, or by somebody authorized
 by the owner.

We can use holistic specifications to express our understanding of
these circumstances, by specifying the necessary conditions for a
decrease in a participant's balance, and the necessary conditions for
authorization.

A decrease in  a participant's balance 
(\ie  $\prg{e}.\prg{balance}=...\, \wedge\, \Next{\prg{e}.\prg{balance}=...}$)
can only be caused by a transfer instigated by the 
account holder themselves (\ie $\Calls{\prg{p}, ...}$), or by
a transfer instigated by another participant $\prg{p}''$  (\ie $\Calls{\prg{p}''...}$) who 
has authority for more than the tokens spent(\ie  $\prg{e}.\prg{allowed}(\prg{p},\prg{p}'')\geq \prg{m}'$)
This is described by the following policy, which
binds any \prg{e} which is an \prg{ERC20}  contract:

\vspace{.15cm}
\noindent
% \strut \hspace{0.3cm} 
$\forall \prg{e}:\prg{ERC20}.\forall \prg{p}:\prg{Object}.\forall \prg{m},\prg{m}':\prg{Nat}.$\\
\strut \hspace{0.3cm} $[\ \ \prg{e}.\prg{balance}=\prg{m}+\prg{m'}\ \wedge \ \Next{\prg{e}.\prg{balance}=\prg{m}'}$ \\ %.\forall\prg{m}:\prg{Nat}.$\\
\strut \hspace{0.4cm} \ \ \ $\longrightarrow$\\
\strut \hspace{0.4cm} \ \ \ $\exists \prg{p}',\prg{p}'':\prg{Object}.$ \\
\strut \hspace{0.4cm} \ \ \  $[\ \  \Calls{\prg{p},\prg{e.transfer(p',m)},\_} \  \  \ \vee\, $\\
\strut \hspace{0.4cm} \ \ \   $\ \ \ \ \prg{e}.\prg{allowed}(\prg{p},\prg{p}'')\geq \prg{m} \ \wedge \ \Calls{\prg{p}'',\prg{e.transferFrom(p,p',m),\_}}\       \  ]$\\
\strut \hspace{0.3cm} $] $
\vspace{.15cm}

\noindent
That is to say: if next configuration witnesses a decrease of the balance by
 $\prg{m}'$, then the current configuration was a call of \prg{transfer} instigated by
 the owner, or it was a call of \prg{transferFrom} instigated by somebody authorized.
Note the term \prg{e}.\prg{allowed}(\prg{p},\prg{p}''), which means that the
ERC20 variable \prg{e} holds a field called \prg{allowed} of   mapping type, which maps pairs of participants to numbers; such
mappings are supported in Solidity\cite{Solidity}, but could also be
 understood as ghost fields or predicates\footnote{cite ghost
 field\kjx{actually, be clear about the context, \Chainmail seems to
 have its own ghost fields, so we just use them without apology}}.
Also, % allow for fields which are mappings, as supported
we use an underscore ($\_$) to indicate some value or variable of no importance; thus the term $\Calls{\prg{p}'',\prg{e.transferFrom(p,cl',m),\_}}$ is a convenient shorthand for 
$\exists \prg{m}''.\Calls{\prg{p}'',\prg{e.transferFrom(p,cl',m),m''}}$. \kjx{thjis
 shorthand should go into the overview of chainmail, if we want to
 keep it. add a ``notational conventions'' section or something.}

We now define what it means for $\prg{p}$ to have authorized $\prg{p}'$ to  spend 
up to \prg{m} tokens on the behalf of $\prg{p}$: At some point in the
past,  \prg{p} gave authority to $\prg{p}'$  to spend   \prg{m}
plus the sum of  tokens
spent so far by $\prg{p}' $ on the behalf of \prg{p}. 

 
\vspace{.15cm}
\noindent
 $\forall \prg{e}:\prg{ERC20}.\forall \prg{p},\prg{p'}:\prg{Object}.\forall \prg{m}:\prg{Nat}.$\\
\strut \hspace{0.3cm} $[\ \ \prg{e}.\prg{allowed}(\prg{p},\prg{p}')=\prg{m} $\\
\strut \hspace{0.4cm} \ \ \ $\longrightarrow$\\
\strut \hspace{0.4cm} \ \ \  
     $\PrevId\langle\ \  \Calls{\prg{p},\prg{e}.\prg{approve}(\prg{p}',\prg{m})} $\\
      \strut \hspace{1.7cm} \ $\vee $\\
\strut \hspace{1.7cm} \  
     $    \prg{e}.\prg{allowed}(\prg{p},\prg{p}')=\prg{m}   
        \  \wedge\ $\\
\strut \hspace{1.5cm} \ \ \ \ \          $  \neg   (\, \Calls{\prg{p}',\prg{e.transferFrom(p,\_,\_)},\_ }\, \vee \, \Calls{\prg{p},\prg{e}.\prg{approve}(\prg{p}',\_)\ }\, ) $\\
      \strut \hspace{1.7cm}\  $\vee $\\
\strut \hspace{1.7cm}   \  $ \exists \prg{p}'':\prg{Object}.\exists\prg{m'}:\prg{Nat}.$\\
 \strut \hspace{1.7cm}\  $[\   
  \prg{e}.\prg{allowed}(\prg{p},\prg{p}')=\prg{m}+\prg{m}'  \, \wedge\,   \Calls{\prg{p}',\prg{e.transferFrom(p,p'',\prg{m}')},\_ }\  ]$\\
\strut \hspace{0.4cm} \ \ \  \ \ \  \ \ \ \ \ $\rangle $\\
\strut \hspace{0.3cm} $]$
\vspace{.15cm}
 
In more detail, $\prg{p}'$ is allowed to spend 
up to \prg{m} tokens on their behalf of $\prg{p}$, if in the immediately previous step either a)
 \prg{p} made the call \prg{approve} on \prg{e} 
with arguments $\prg{p}'$ and \prg{m}, or b)  
$\prg{p}'$ was allowed to spend  up to \prg{m} tokens for $\prg{p}$
and did not transfer any of \prg{p}'s tokens, nor did \prg{p} issue a fresh authorization,
or c) \prg{p} was authorized for $\prg{m}+\prg{m}'$ and spent $\prg{m}'$ 
\kjx{This seems to be MUCH NICER than the previous versions. Still
stepwise, but a better style of definition}.  
 

 Thus, the holistic specification gives to account holders an
 "authorization-guarantee": their balance cannot decrease unless they
 themselves, or somebody they had authorized, instigates a transfer of
 tokens. Moreover, authorization is {\em not} transitive: only the
 account holder can authorise some other party to transfer funds from
 their account: authorisation to spend from an account does not confer
 the ability to authorise yet more others to spend also.
 
\paragraph{Comparison with Traditional Specifications}
 
 Traditional  specifications %for the ERC20 example would consist of
 describe the behaviour of each function separately.
 They  consist of pre- and post- conditions for each function; the pre-condition is 
 a {\em sufficient} condition for the effect of the particular function.
 Usually, for each function, we need one specification for the case 
 where the function's pre-condition holds, another for the case where it does not.\footnote{ARGH! 
 Here we use pre-condition with two different meanings! What to do?}
 \kjx{HUh? why?  we support/need this, but traditional contracts,
 Hoare, Meyer \& co, don't!}  
With traditional  specifications, to obtain the "authorization-guarantee", 
one would need to inspect the pre- and post- conditions of {\em all} the functions
in the contract, and determine which of the functions decrease balances, and which of the functions 
 affect authorizations.
 In the case of the \prg{ERC20}, one would have to inspect all eight such specifications, 
 where only five are relevant to the question at hand.
 In other cases, \eg the DAO, the number of the functions which are unrelated
 to the question at hand can be very large.
 Moreover, with the traditional specification, the "authorization-guarantee" can only be 
 obtained if  all the functions have pre- and post-conditions which we
 trust while this is not necessaty for the
 holistic case.
 
More importantly, with traditional  specifications, nothing stops the next release of the contract to add, 
\eg, a method which allows participants to share their authority, and thus
violate the "authorization-guarantee", or even a super-user from skimming 0.1\% from each of the accounts.

In Figure \ref{fig:classicalERC20} we outline a traditional specification for the \prg{ERC20}.
We give two speficiations for \prg{transfer}, another two for \prg{tranferFrom}, and one for all 
the remaining functions. The  first specification says, \eg, that if  
 \prg{p} has sufficient tokens, and it calls \prg{transfer}, then the transfer will take place.  
The second specification says that  if \prg{p} has insufficient tokens, then 
the transfer will not take place (we assume that in this
specification language, any entities not mentioned in the pre- or post-condition 
are not affected).\footnote{cite framing -- but anyway, our subject is
not the classical spec.} \kjx{again why. classical specs just say WTF
happens if preconditions are met, and intentionally do not say what
happens if they are not met.  Two specs is one of our innovations,
isn't it. One we dont want to talk about here, but...}
 
 Similarly, we would have to give another two specifications to define the behaviour of 
if \prg{p''} is authorized and executes \prg{transferFrom}, then   the balance decreases. 
But they are {\em implicit} about the overall behaviour and the   {\em necessary} conditions,
e.g., what are all the possible actions that can cause a decrease of balance?


 
\begin{figure}   
\fbox{
$
\begin{array}{c}
 \prg{e}:\prg{ERC20}\ \wedge\  \prg{p},\prg{p''}:\prg{Object} 
  \wedge\ \prg{m},\prg{m}',\prg{m}'':\prg{Nat}\ \wedge\   \\
 \prg{e}.\prg{balance(p)} = \prg{m}+\prg{m}'\ \ \wedge\ \ \prg{e}.\prg{balance(p'')} = \prg{m}''\ \ \wedge\ \ \prg{this}=\prg{p} \\
   \{ \ \ \prg{e.transfer(p'',m')} \ \ \}   \\
    \prg{e}.\prg{balance(p)} = \prg{m}\ \ \wedge\ \ \prg{e}.\prg{balance(p'')} = \prg{m}''+\prg{m}'
\ \ \\
\ \ \\
  \prg{e}:\prg{ERC20}\ \wedge\  \prg{p},\prg{p'}:\prg{Object}  \wedge\ \prg{m},\prg{m}',\prg{m}'':\prg{Nat}\ \wedge\     \prg{e}.\prg{balance(p)} = \prg{m} \ \ \wedge \prg{m} <  \prg{m}'  \\
   \{ \ \ \prg{e.transfer(p',m')} \ \ \}   \\
  \prg{e}.\prg{balance(p)} = \prg{m}  
  \\
  \\
\prg{e}:\prg{ERC20}\ \wedge\  \prg{p},\prg{p'},\prg{p}'':\prg{Object} 
  \wedge\ \prg{m},\prg{m}',\prg{m}'',\prg{m}''':\prg{Nat}\ \wedge\   \\
 \prg{e}.\prg{balance(p)} = \prg{m}+\prg{m}'\ \ \wedge\ \ \prg{e}.\prg{allowed(p,p')}=\prg{m}'''+\prg{m}' \ \wedge\\
  \prg{e}.\prg{balance(p'')} = \prg{m}''\ \ \wedge\ \ \prg{this}=\prg{p'} \\
   \{ \ \ \prg{e.transferFrom(p',p'',m')} \ \ \}   \\
    \prg{e}.\prg{balance(p)} = \prg{m}\ \ \wedge\ \ \prg{e}.\prg{balance(p'')} = \prg{m}''+\prg{m}'
     \ \wedge\ \ \prg{e}.\prg{allowed(p,p')}=\prg{m}'''
\ \ \\
\ \ \\
  \prg{e}:\prg{ERC20}\ \wedge\  \prg{p},\prg{p'}:\prg{Object}  \wedge\ \prg{m},\prg{m}',\prg{m}'':\prg{Nat}\ \wedge\ \prg{this}=\prg{p}' \ \wedge \\
      ( \ \prg{e}.\prg{balance(p)} =\prg{m} \wedge \prg{m} <  \prg{m}''\  \vee \ 
  \prg{e}.\prg{allowed(p,p')}=\prg{m'} \wedge \prg{m'} < \prg{m}'' \ ) \\
   \{ \ \ \prg{e.transferFrom(p,p'',m'')} \ \ \}   \\
  \prg{e}.\prg{balance(p)} = \prg{m} \wedge  \prg{e}.\prg{allowed(p,p')}=\prg{m'}
  \\
  \\
  \prg{e}:\prg{ERC20}\ \wedge\  \prg{p},\prg{p'}:\prg{Object}  \wedge\ \prg{m}:\prg{Nat}\ \wedge\ \prg{this}=\prg{p}  \\
   \{ \ \ \prg{e.approve(p',m')} \ \ \}   \\
  \prg{e}.\prg{allowed(p,p')} = \prg{m} 
  \\
  \\
   \prg{e}:\prg{ERC20}\ \wedge\ \prg{m}:\prg{Nat}\ \wedge\    \prg{p}.\prg{balance}=\prg{m}    \\
   \{ \ \ \prg{k}=\prg{e.balanceOf(p)} \ \ \}   \\
  \prg{k}=\prg{m} \ \wedge \ \prg{e.balanceOf(p)} = \prg{m}  
  \\
  \\
   \prg{e}:\prg{ERC20}\ \wedge\ \prg{m}:\prg{Nat}\ \wedge\    \prg{e}.\prg{allowed(p,p')}=\prg{m}    \\
   \{ \ \ \prg{k}=\prg{e.allowance(p,p')} \ \ \}   \\
  \prg{k}=\prg{m} \ \wedge \ \prg{e}.\prg{allowed(p,p')}=\prg{m} 
  \\
  \\
   \prg{e}:\prg{ERC20}\ \wedge\ \prg{m}:\prg{Nat}\ \wedge\     \sum_{\prg{p}\in dom(\prg{e}.\prg{balance})}^{}{\prg{e}.\prg{balance}(\prg{p})}=\prg{m}    \\
   \{ \ \ \prg{k}=\prg{e.totalSupply()} \ \ \}   \\
  \prg{k}=\prg{m}   
\end{array}
$
}
\caption{Classical specification for the \prg{ERC20}}
\label{fig:classicalERC20}
\end{figure}
