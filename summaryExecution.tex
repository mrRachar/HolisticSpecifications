\renewcommand{\appref}[1]{, c.f. Appendix, Def.\,\ref{#1}}
 
 
As was have already seen, \Chainmail assertions not only talk about the contents of the current state (stack frame and heap),
but they also talk about future and past states, Therefore, the meaning to \Chainmail assertions depends on the existence of an
underlying object oriented programming language, with modules (\M) as repositories of code, objects described by classes,
a concept of linking several modules together, and a concept of 
program execution, where  actions that happen within the objects belonging to a module are considered atomic.

In this section, we outline a minimal such language, which we call  \LangOO, but we believe that \Chainmail can be applied to 
any language that supports the features listed above. 
Full, and mostly unsurprising,
 definitions for  \LangOO~appear in Appendix \ref{app:LangOO}. 
In this section we summarize the more conventional parts, and describe the novel aspects. 

Central to our work is the concept of \emph{module}, which is a repository of code. Modules map class identifiers to class definitions, \appref{defONE}; and class definitions consist of field, method and ghost field declarations, \appref{def:syntax:classes}.  \LangOO is untyped -- this reflects the open world, where we link with external modules which come without any guarantees. \footnote{In further work we want to work in a setting where the internal module is typed, and the external is untyped.} Method bodies are sequences of
statements, which  can be field read or field assignments, object creation, method calls, and return statements.
%All else, \eg booleans, conditionals, loops,  can be encoded.
All fields are private in the sense of C++: Field read or write is only allowed  if the object whose field is being read 
belongs to the same class as the current method. 
This is enforced by the operational semantics, \cf Fig.  \ref{fig:Execution}.
We will discuss ghost fields in the next section.

Runtime configurations, $\sigma$,  contain   all pertinent information about an execution snapshot: the heap, and a
stack of fames. Each frame consists of a continuation, \prg{contn}, and a map from variables to values. 
We define execution  through a judgment of the form $\M, \sigma \leadsto \sigma'$ in the Appendix, Fig.  \ref{fig:Execution}. 
%
  

In  order to deal with the distinction of external and internal modules, we define a module linking operator,  $\link$ so that
$\M\link\M'$ is the union of the two modules, provided that their domains are disjoint, \appref{def:link}.
%
As we said earlier, in execution we distinguish  between the internal and external module, and treat  execution of 
methods from the internal module as atomic. For this, we define\sd{ \emph{two-module execution} } as follows:

\begin{definition}
\label{def:execution:internal:external}
\label{def:module_pair_execution} 
Given runtime configurations $\sigma$,  $\sigma'$,  and a module-pair $\M \mkpair \M'$ we define
execution where $\M$ is the internal, and $\M'$ is the external module as below:
 
\begin{itemize}
\item
$\M \mkpair \M', \sigma \leadsto \sigma'$ \IFF
there exist  $n\geq 2$ and runtime configurations $\sigma_1$,  ...
$\sigma_n$, such that
\begin{itemize}
\item
$\sigma$=$\sigma_1$,\ \  \ \ and\ \ \ \ $\sigma_n=\sigma'$.
\item
$\M \link \M', \sigma_i \leadsto \sigma_{i+1}'$,\  \  for $1\leq i \leq n\!-\!1$
\item
$\ClassOf{\this} {\sigma}\not\in dom({\M})$,  \ \  \ \ and\ \ \ \
$\ClassOf{\this} {\sigma'} \not\in dom({\M})$,
\item
 $\ClassOf{\this} {\sigma_i} \in dom({\M})$,\ \ \ \ for $2\leq i \leq n\!-\!2$
\end{itemize}
\end{itemize}

\end{definition}

In the definition above,  $\ClassOf {\x} {\sigma} $ looks up the class of the object stores at \x, \appref{def:interp}.
If  $n$  has the value $2$, %. In this case the final bullet is trivial and  
then  there exists a direct, external transition from $\sigma$ to $\sigma'$.  Our definition is related to the concept of visible states semantics\cite{MuellerPoetzsch-HeffterLeavens06}, but differs in that visible states semantics select the configurations at which an invariant is expected to hold, while we select the states which are considered for executions which are expected to satisfy an invariant. 
% SD deleted the below, as I do not like it any more
% Our assertions can talk about several states (through the use of the $\Future {\_}$ and $\Past{\_}$ connectives), and thus, the intention of ignoring some intermediate configurations can only be achieved if we refine the concept of execution.

The lemma below says  that linking is associative and commutative, and preserves (modular) execution.

\begin{lemma}[Properties of linking]
 For any modules $\M$,   $\M'$, $\M''$, and $\M'''$ and runtime configurations $\sigma$, and $\sigma'$ we have$:$
 \label{lemma:linking:properties}

 \begin{itemize}
     \item
     $(\M \link \M')\link \M''$ = $\M \link (\M' \link \M'')$  \hspace{1cm} and    \hspace{1cm}   $\M \link \M'$  = $\M' \link\M$.
      \item
      $\M, \sigma \leadsto \sigma'$, and $\M\link \M'$ is defined, \  \ \ \ \  implies\ \ \ \ \   $\M\link \M', \sigma \leadsto \sigma'$.
 \item
 $\M \mkpair \M', \sigma \leadsto \sigma'$   \  \ \ \ \  implies\ \ \ \ \  $(\M\link\M'') \mkpair (\M'\link\M''') ,\sigma \leadsto \sigma'$.  
  \end{itemize}

 \end{lemma}
 
 We can now answer the question as to which runtime configurations are pertinent when judging a module's
adherence to an assertion.
We define as  {\em arising} configurations those that can be reached by two-module execution, starting from any initial configuration.
An initial configuration has a heap with only one object, of class \prg{0bject}, and only one frame, whose continuation may be arbitrary.
 
\begin{definition}[Initial and Arising Configurations] are defined as follows: \label{defn:iniial-and-arising}
MuellerPoetzsch-HeffterLeavens06
\begin{itemize}
     \item
   $\Initial {(\psi,\chi)}$, \ \ if \ \ $\psi$ consists of a single frame $\phi$ with $dom(\phi)=\{ \this \}$, and there exists  some address $\alpha$, such that \ \ \    $\interp {\this}{\phi}$=$\alpha$, and \ $dom(\chi)$=$\alpha$,\  and\  
    $\chi(\alpha)=(\prg{Object},\emptyset)$.
 \item
 $\Arising  {\M\mkpair\M'} \ = \ \{ \ \sigma \ \mid \ \exists \sigma_0. \ [\  \Initial{\sigma_0} \  \ \wedge\ \  \M\mkpair\M', \sigma_0 \leadsto^* \sigma \ \ ] \ \ \} $
 \end{itemize}

\end{definition}

 


