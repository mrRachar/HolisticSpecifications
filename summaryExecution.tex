 %\newcommand{\appref}[1]{, c.f. App. Def.\ref{#1}}
 
 
As was have already seen, \Chainmail assertions not only talk about the contents of the current state (stack frame and heap),
but they also talk about future and past states, Therefore, the meaning to \Chainmail assertions depends on the underlying programming
language. In this section, we outline a minimal such language, which we call  \LangOO. Full definitions appear in Appendix \ref{app:LangOO}. \sophia{TODO-say which features need to be in such a language and say that \LangOO is an example of such one.}

Central to our work is the concept of \emph{module}, which is a repository of code. Modules map class identifiers to class definitions, \appref{defONE}, and class definitions consist of method declarations and field declarations, \appref{def:syntax:classes}.  \LangOO is untyped -- this reflects the open world, where we link with external modules which come without any guarantees. \footnote{In further work we want to work in a setting where the internal module is typed, and the external is untyped.} Statements
these can be field read or field assignments, object creation, method calls, and return statements.
%All else, \eg booleans, conditionals, loops,  can be encoded.
All fields are private in the sense of C++: Field read or write is only allowed  if the object whose field is being read 
belongs to the same class as the current method. 
This is enforced by the operational semantics, \cf
Fig.  \ref{fig:Execution}.

We use runtime configurations $\sigma$ to describe   all pertinent information about an execution snapshot: the heap, and a
stack of fames. Each frame consists of a continuation, \prg{contn} and a map from variables to values. We define execution  through a judgment of the form $\M, \sigma \leadsto \sigma'$ in the Appendix, Fig.  \ref{fig:Execution}. 

We also  define the
interpretation of of simple expressions through $\interp e {\sigma}$, and class look-up through $\ClassOf {e} {\chi} $, \appref{def:interp}.
  

In  order to deal with the distinction of external and internal modules, we define a module linking operator,  $\link$ si that
$\M\link\M'$ is the union of the two modules, provided that their domains are disjoint, \appref{def:link}.


As we said earlier, our notion of execution distinguishes between the internal and external module, and treats execution of 
methods from the internal module as atomic. Therefore we define \emph{modular execution} \sophia{better term} as follows:

\begin{definition}
\label{def:execution:internal:external}
\label{def:module_pair_execution} 
Given runtime configurations $\sigma$,  $\sigma'$,  and a module-pair $\M \mkpair \M'$ we define
execution where $\M$ is the internal, and $\M'$ is the external module as below:
 
\begin{itemize}
\item
$\M \mkpair \M', \sigma \leadsto \sigma'$ \IFF
there exist  $n\geq 2$ and runtime configurations $\sigma_1$,  ...
$\sigma_n$, such that
\begin{itemize}
\item
$\sigma$=$\sigma_1$,\ \  \ \ and\ \ \ \ $\sigma_n=\sigma'$.
\item
$\M \link \M', \sigma_i \leadsto \sigma_{i+1}'$,\  \  for $1\leq i \leq n\!-\!1$
\item
$\ClassOf{\this} {\sigma}\not\in dom({\M})$,  \ \  \ \ and\ \ \ \
$\ClassOf{\this} {\sigma'} \not\in dom({\M})$,
\item
 $\ClassOf{\this} {\sigma_i} \in dom({\M})$,\ \ \ \ for $2\leq i \leq n\!-\!2$
\end{itemize}
\end{itemize}

\end{definition}

In the definition above $n$ is allowed to have the value $2$. In this case the final bullet is trivial and  there exists a direct, external transition from $\sigma$ to $\sigma'$.  Our definition is related to the concept of visible states semantics, but differs in that visible states semantics select the configurations at which an invariant is expected to hold, while we select the states which are considered for executions which are expected to satisfy an invariant. 
% SD deleted the below, as I do not like it any more
% Our assertions can talk about several states (through the use of the $\Future {\_}$ and $\Past{\_}$ connectives), and thus, the intention of ignoring some intermediate configurations can only be achieved if we refine the concept of execution.

The lemma below says  that linking is associative and commutative, and preserves (modular) execution.

\begin{lemma}[Properties of linking]
 For any modules $\M$,   $\M'$, $\M''$, and $\M'''$ and runtime configurations $\sigma$, and $\sigma'$ we have$:$
 \label{lemma:linking:properties}

 \begin{itemize}
     \item
     $(\M \link \M')\link \M''$ = $\M \link (\M' \link \M'')$  \hspace{1cm} and    \hspace{1cm}   $\M \link \M'$  = $\M' \link\M$.
      \item
      $\M, \sigma \leadsto \sigma'$, and $\M\link \M'$ is defined, \  \ \ \ \  implies\ \ \ \ \   $\M\link \M', \sigma \leadsto \sigma'$.
 \item
 $\M \mkpair \M', \sigma \leadsto \sigma'$   \  \ \ \ \  implies\ \ \ \ \  $(\M\link\M'') \mkpair (\M'\link\M''') ,\sigma \leadsto \sigma'$.  
  \end{itemize}

 \end{lemma}


