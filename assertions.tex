%\section{ Assertions}
%\label{sect:assertions}

\subsection{The syntax of Expressions and Assertions}

%\secomment
\susan{if you like this I will write macros so as not to have parameter lists with the keywords, alternatively this list could just have the identifiers and no descriptions\sd{not clear what is meant}}
In section~\ref{sect:chainmail} we introduced our assertion language \Chainmail with keywords 
$\CanAccess{}{}$ to check whether one object can call another, $\Calls{}$ for the current function call, 
$\Changes{}$ to check whether the next configuration will affect validity of some assertion, and 
 $\Next {}$ or $\Future {}$  for expressing an assertion will hold at
the immediate successor execution point or at some future point, and
$\Prev{}$ or $\Past{}$ to express  that an assertion held at the immediately previous or
some point in the past, and  $\Using{}{}$, 
for expressing that an assertion holds in
the sub-configuration determined by a witness.

The keywords enable \Chainmail assertions to support 
reflection over various aspects of the current 
runtime configurations, reflection over past or future configurations, and 
reflection over sub-configurations.
Assertions can contain logical operators and interestingly, the existential and universal quantifiers may quantify over object addresses, as well as 
over sets of addresses, numbers, and sequences of field identifiers of a given length.


%\secomment
\susan{if you prefer this paragraph then link it back to section 4. \sd{Yes, it may now be superfluous.}}


Assertions, $\A$, support standard logical operators, 
reflection over various aspects of the current 
runtime configurations, reflection over past or future configurations, and 
reflection over sub-configurations.
The standard logical operators are, unsurprisingly,
 $\wedge$, $\vee$, $\rightarrow$, $\neg$, $\exists$ and $\forall$.
Interestingly, the existential and universal quantifiers may quantify over object addresses, but also 
over sets of addresses, numbers, and sequences of field identifiers of a given length.
When reflecting over the current state, we can reflect over the class and contents of objects
(\eg \x:\prg{ClassId} or \x.\f=\y.\f'), whether an
object has direct access to (and thus may call on) another object $\CanAccess{\_}{\_}$,
and the current function call $\Calls{\prg{\_},\prg{\_},\prg{\_},\prg{\_}}$.
We can also talk about whether the next configuration will affect the 
validity of some assertion $\Changes{\_}$
\footnote{Note that $\Changes{\_}$ may be encoded; do we keep it?
The reason to keep it is that we can then talk of "permission" and "authority" }.  
We also support {\em temporal} modifiers, where $\Next \A$ or $\Future \A$  express  that $\A$ will hold at
the immediate successor execution point or at some future point, while
$\Prev \A$ or $\Past \A$ express  that $\A$ held at the immediately previous or
some point in the past.
Finally, we support a {\em spatial modifier}, $\Using{\A}{S}$, 
which expresses that assertion $\A$ holds in
the sub-configuration determined by the witness \prg{S}.


\begin{definition}[Assertions] The syntax of simple expressions $\SE$) and assertions ($\A$) is:
\label{def:assertions}

 $\begin{array}{lcl}
  \SE & ::= &  \prg{true}  \ \mid\ \prg{false}  \    \mid\ \prg{null}  \ \mid \ \x  \ \mid \ \SE.\f    \ \mid \ \SE.\f^n \   \ \mid\  \ \\
 ~ \\
\A &\ ::=\  &   \SE  \ \mid \ \SE > \SE \ \mid \  \SE=\SE  \ \mid \ \SE \equiv \SE\ \mid \   \SE:\prg{ClassId}  \ \mid \
    \SE\in\prg{S}   \ \mid  \ \A \rightarrow \A  \ \mid\  \  \\
 &   &  \exists \x.\A  \ \mid \  \exists \prg{S}:SET.\A  \ \mid \  \exists fs:FLD^k.\A
 \ \mid \  \exists k:\mathbb{N}.\A  \ \mid\  \
\\
 &    & \CanAccess x y \ \mid\  \ \Changes e \ \mid\  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}} \ \mid\  \\  
 &    &  \Next \A  \ \mid \   \Future \A \ \mid \  \Prev \A    \ \mid \  \Past \A \ \mid \ \Using \A \prg{S }  \ \mid\  \
% \\
 \\
  &   &  \A \wedge \A  \ \mid\  \ \A \vee \A  \ \mid\  \ \neg A   \ \mid\  \ \forall \x.\A  \ \mid \  \forall \prg{S}:SET.\A  \ \mid \  \forall fs:FLD^k.\A
 \ \mid \  \forall k:\mathbb{N}.\A
\end{array}$


\end{definition}

Note that the operators $\wedge$, $\vee$,  $\neg$ and $\forall$  could have been defined  through the usual shorthands, \eg, $\neg \A$ is short for
$\A \rightarrow \ff$ \etc, but here we give full definitions instead.
 Validity of assertions has the format $\M\mkpair \M', \sigma \models \A$, where  $\M$ is the internal module, whose internal workings
 are opaque to the external, client module $\M'$.

\subsection{Configuration adaptation and configuration restrictions}
In order to define whether a runtime configuration satisfies an assertion we need two auxiliary concepts:
the adaptation of a runtime configuration to another one, and the restriction of a runtime configuration to only the set of objects from a
given set.

We need adaptation to deal with time, and the corresponding changes of scope. For example, the assertion
$\Future {\x.\f=\prg{3}}$, is satisfied if in some {\em future} configuration, the field  \f\, of the object that is pointed at by \x\, in the {\em current} configuration has the value \prg{3}; note that in the future  configuration, \x\, may be pointing to a different object, or may
even no longer be in scope (\eg if a nested call or a nesting call is executed).
Therefore, we introduce the operator \  $\adapt\;$,  \ \ which combines runtime configurations: $\sigma \adapt \sigma'$ adapts the second configuration to the top frame's view of the former: it returns a new configuration whose stack has  the top frame as taken from $\sigma$ and where the \prg{contn} has been consistently renamed, while the heap is taken from $\sigma'$. This allows us to interpret expressions  in the newer (or older) configuration $\sigma'$ but with the variables bound according to the top frame from $\sigma$; \eg we can obtain that value of \prg{x}.\prg{f} in configuration  $\sigma'$ even if \prg{x} was out of scope. The consistent renaming of the code allows the correct modelling of execution (as needed,   for the semantics of  nested time assertions, as \eg in $\Future {\x.\f=\prg{3} \wedge \Future {\x.\f=\prg{5}}}$


 \begin{definition}[Adaptation on Runtime Configurations]  The operator $\adapt$\ \  is a binary operator on runtime configurations.
 \label{def:config:adapt}
 $~ $

\begin{itemize}
\item
$\sigma \adapt \sigma' \triangleq (\phi''\cdot\psi',\chi')$  \IFF $\sigma=(\phi\cdot\_,\_)$, and $\sigma'= (\phi'\cdot\psi',\chi')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $
$\phi$=$(\prg{contn},varMap)$, and $\phi'$=$(\prg{contn}',varMap')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $     % $\phi''$ such that
  $\phi''=(\, \prg{contn}'[\prg{zs}/\prg{zs}' ],\,varMap'[\prg{zs}'\mapsto varMap(\prg{zs})]\, ) $, where
 \\
$\ \strut \ \ \hspace{1.45in} $
\prg{zs}=$dom(varMap)$, and
 \\
$\ \strut \ \ \hspace{1.45in} $      $\prg{zs}'$ is a set  of variables with  the  same cardinality as \prg{zs}, and
 \\
$\ \strut \ \ \hspace{1.45in} $   all variables in
$\prg{zs}'$  are fresh in $varMap$ and in $varMap'$.


\end{itemize}

\end{definition}

 On the other hand, an assertion of the form $\Using{A}{S}$ promises that $\A$ holds in subconfiguration, whose heap is restricted to the objects from \prg{S}.

 \begin{definition}[Restriction on Runtime Configurations]  The restriction operator~$\;\restrct{} {} $ applied to a runtime configuration $\sigma$ and a set $R$ is defined as follows:
 \label{def:config:restrct}
 $~ $

\begin{itemize}
\item
$\restrct {\sigma}{\prg{S}} \ \triangleq \ (\phi, \chi')$, \IFF  $\sigma$=$(\phi,\chi)$, \ and  \  $dom(\chi')=\interp {\prg{S}} {\sigma}$, and  \\
$\ \strut \ \ \hspace{1.2in} $
 $\forall \alpha\!\in\!dom(\chi').[ \ClassOf {\alpha} {\chi'} =  \ClassOf {\alpha} {\chi}\ \wedge \ \forall \f.  \chi'(\alpha,\f)=\chi(\alpha,\f)]$.
\end{itemize}
\end{definition}

\subsection{Satisfaction of assertions}



\begin{definition}[Interpretations for simple expressions]

For any runtime configuration, $\sigma$, and any $k\in \mathbb{N}$, and any simple expression, $\SE$, we define its interpretation as follows:

\begin{itemize}
     \item
  $\interp {\prg{true}}{\sigma}$ $ \triangleq$   \prg{true}, \ and \ \    $\interp {\prg{false}}{\sigma}$ $ \triangleq$ \prg{false}, \ and \ \
   $\interp {\prg{null}}{\sigma}$ $ \triangleq$  \prg{null}
  \item
  $\interp {\x}{\sigma}$ $ \triangleq$ $\phi(\x)$  \ \ if \ \ $\sigma$=$(\phi\cdot\_,\_)$
  \item
  $\interp {\SE.\prg{f}}{\sigma}$ $ \triangleq$ $\chi({\interp {\SE}{\sigma}}, \prg{f})$  \ \ if \ \ $\sigma$=$(\_,\chi)$
   \item
     $\interp {\SE.\prg{f}^0}{\sigma}$ $ \triangleq$  $\interp {\SE}{\sigma}$, \ \ \ and \ \ \ $\interp {\SE.\prg{f}^{k+1}}{\sigma}$ $ \triangleq$   $\chi({\interp {\SE.\prg{f}^k}{\sigma}})(\prg{f})$, where $\sigma$=$(\_,\chi)$.
   \end{itemize}
\end{definition}

\begin{lemma}[Interpretation corresponds to execution]
For any simple expression $\SE$, runtime configuration $\sigma$, and value $v$:

\begin{itemize}
     \item
  $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M_\emptyset, \sigma[\prg{contn}\mapsto \SE] \leadsto v$,\\
  where $\M_\emptyset$ stands for the empty module.
  \item
   $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M, \sigma[\prg{contn}\mapsto \SE] \leadsto v$ \ \ \ for any module $\M$ .
   \end{itemize}
   \end{lemma}

   \begin{proof} The  first guarantee is proven structural induction  over the definition of $\SE$.
   The second guarantee  is a corollary of the first guarantee  and of lemma \ref{lemma:linking:properties}.\end{proof}


\begin{definition}[Satisfaction of  Assertions] We define below when a configuration satisfies an assertions. We first extend the definition of interpretation
to simple expressions.
\label{def:valid:assertion}

We first consider simpler assertions which only involve expressions:

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models\SE$ \IFF  $\interp{\SE}{\sigma}$ = \prg{true}.
\item
$\M\mkpair \M', \sigma \models\SE>\SEPrime$ \IFF $\interp{\SE}{\sigma}$ > $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE=\SEPrime$ \IFF $\interp{\SE}{\sigma}$ = $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE\equiv\SEPrime$ \IFF $\SE$ and $\SEPrime$ are textually identical.
\item
$\M\mkpair \M', \sigma \models \SE:\prg{ClassId}$ \IFF $\ClassOf {\interp{\SE}{\sigma}} {\sigma}$ = $\prg{ClassId}$.
\item
$\M\mkpair \M', \sigma \models \SE\in \prg{S}$ \IFF $\interp{\SE}{\sigma}\in \interp{\prg{S}}{\sigma}$.
\end{itemize}

Next, we consider assertions involving existential quantifiers over program variables, field sequences, sets and numbers.

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models \exists x.\A$ \IFF
$\M\mkpair \M', \sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$ \ for some  $\alpha\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$.\item
$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}\!.\,\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
$\strut ~ \hspace{1.4in} $ for some set of addresses $R\subseteq dom(\sigma)$, and   \prg{Q} free in $\sigma$ and $\A$.

\item
$\M\mkpair \M', \sigma \models  \exists \prg{fs}:\prg{FLD}^k\!.\,\A$ \IFF
$\M\mkpair \M', \sigma \models  \A[\prg{fs}/\prg{f}_1.\f_2.\,...\,\prg{f}_k]$\  for  $k$ field identifiers $\prg{f}_1$,..,$\prg{f}_k$.
\item
$\M\mkpair \M', \sigma \models  \exists \prg{n}:\prg{Nat}.\A$ \IFF  $\M\mkpair \M', \sigma \models \A[\prg{n}/k]$\ \ for some $k\in\mathbb{N}$.

\end{itemize}

And now, we consider the assertions which involve space, time or control:

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models  \CanAccess{\prg{x}}{\prg{y}}$   \IFF  \begin{itemize}
\item
$\interp {\x} {\sigma}$=$\interp {\y} {\sigma}$, or
\item
$\interp {\x.\f} {\sigma}$=$\interp {\y} {\sigma}$  for some field \prg{f},  or
\item
$\interp {\x} {\sigma}$=$\interp {\this} {\sigma}$ and
  $\interp {\y} {\sigma}$=$\interp {\z} {\sigma}$,
\
and \z\ appears in  $\sigma$.\prg{contn}.\footnote{
That is, $\CanAccess{\prg{x}}{\prg{y}}$ expresses that \x has a {\em direct} path to \y.
In more detail, in the current frame,
either \x and \y\, are  aliases, or \x points to an object which has a field
whose value is the same as \y, or \x is the currently executing object and \y is
 a local variable or formal parameter which appears in the code in the continuation.
 %That means, that variables which were introduced into the variable map in order to give meaning to existentially quantified assertions are not considered.
 }
 \end{itemize}
 \item
 $\M\mkpair \M', \sigma \models   \Changes{\prg{e}}$  \IFF
 $\exists \sigma'.\, [\ \ \M\mkpair \M',\sigma \leadsto \sigma' \ \wedge \interp{e}{\sigma} \neq \interp{e}{\sigma\triangleleft \sigma'} \ \  ]$.
   \item
$\M\mkpair \M', \sigma \models  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}}$ \IFF \
 $\sigma.\prg{contn}$=\prg{u.m(v);\_}\ \ for some variables \prg{u} and \prg{v},  \ and \
\\ $\strut ~ \hspace{1.4in} $
$\interp{\prg{this}}{\sigma}$=$\interp{\prg{x}}{\sigma}$, \ and\ $\interp{\prg{y}}{\sigma}$=$\interp{\prg{u}}{\sigma}$,
 \ and\ $\interp{\prg{z}}{\sigma}$=$\interp{\prg{v}}{\sigma}$.
 \item
  $\M\mkpair \M', \sigma \models  \Next \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto  \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is
so that $\sigma$=$(\phi\cdot\_,\_)$.\footnote{$\M\mkpair \M', \sigma \models  \Future \A $ holds if
$\A$ holds in some configuration $\sigma'$ which arises from execution of $\phi$, where $\phi$ is the top frame of $\sigma$. By requiring that $\phi \leadsto^* \sigma' $ rather than
$\sigma \leadsto^* \sigma' $ we are restricting the set of possible future configurations to
just those that are caused by the top frame.
Namely, we do not want to also consider the effect of  enclosing function calls.
This allows us to write more natural specifications
when giving necessary conditions for some future effect.
}
\item
  $\M\mkpair \M', \sigma \models  \Future \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto^* \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is
so that $\sigma$=$(\phi\cdot\_,\_)$.  
  \item
 $\M\mkpair \M', \sigma \models  \Prev \A $ \IFF
 $\forall \sigma_1, \sigma_2. [\ \ \Initial{\sigma_1}\ \wedge \   \M\mkpair \M', \sigma  \leadsto^*  \sigma_2 \ \wedge \   \M\mkpair \M', \sigma_2  \leadsto   \sigma  
$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \   
 \M\mkpair \M', \sigma\adapt\sigma_2  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
 \item
 $\M\mkpair \M', \sigma \models  \Past \A $ \IFF
 $\forall \sigma_1, ... \sigma_n. [\ \ \Initial{\sigma_1}\ \wedge \  \sigma_n=\sigma 
  \ \wedge \ \forall i\in[1..n). \M\mkpair \M', \sigma_{i} \leadsto  \sigma_{i+1}
$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \  \exists j\in [1..n-1).
 \M\mkpair \M', \sigma\adapt\sigma_j  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
 \item
 $\M\mkpair \M', \sigma \models \Using {\A} {\prg{S}}$
 \IFF
 $\M\mkpair \M', \restrct \sigma {\prg{S}} \models  \A  $.
 \item
  \sd{$\M\mkpair \M', \sigma \models \External {\prg{e}}$}
  \IFF
$\sd{{\interp{\SE}{\sigma}} {\sigma}\notin dom(\M)}$
\end{itemize}

The remaining assertions introduce the remaining logical operators (\ie $\wedge$, $\vee$, $\neg$ and the universal quantifiers). These could be encoded in terms of the preceding operators, but we nevertheless give their meaning explicitly here.

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models \A \rightarrow \A' $ \IFF  $\M\mkpair \M', \sigma \models \A $ implies $\M\mkpair \M', \sigma \models \A' $
\item
$\M\mkpair \M', \sigma \models  \A \wedge \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
and $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \A \vee \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
or $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \neg\A$   \IFF  $\M\mkpair \M', \sigma \models  \A $
does not hold.
\item
$\M\mkpair \M', \sigma \models \forall x.\A$ \IFF
$\sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$ \ for all  $\alpha\in dom(\sigma)$, and   all \prg{z} free in $\sigma$ and $\A$.\item
$\M\mkpair \M', \sigma \models \forall \prg{S}\!\!:\!\!\prg{SET}.\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
$\strut ~ \hspace{1.4in} $ for all sets of addresses $R\subseteq dom(\sigma)$, and  all \prg{Q} free in $\sigma$ and $\A$.

\item
$\M\mkpair \M', \sigma \models \forall \prg{fs}\!\!:\!\!\prg{FLD}^k.\A$ \IFF
$\M\mkpair \M', \sigma \models  \A[\prg{fs}/\prg{f}_1.\f_2.\,...\,\prg{f}_k]$\  for  all  field identifiers $\prg{f}_1$,..,$\prg{f}_k$.
\item
$\M\mkpair \M', \sigma \models  \forall \prg{n}:\prg{Nat}.\A$ \IFF  $\M\mkpair \M', \sigma \A[\prg{n}/k]$\ \ for all $k\in\mathbb{N}$.
\end{itemize}\end{definition}
 
We define equivalence of   assertions in the usual sense: two assertions are equivalent if they are satisfied  in
the context of the same configurations.
Similarly, an assertion entails another assertion, iff all configurations 
which satisfy the former also satisfy the latter.  

\begin{definition}[Equivalence and entailments of assertions]
$ ~ $

\begin{itemize}
\item
$\A \equiv \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ if and only if }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\item
$\A \subseteqq \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ implies }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\end{itemize}
\end{definition}



\begin{lemma}[Assertions are classical-1]
For all runtime configurations $\sigma$,    assertions $\A$ and $\A'$, and modules $\M$  and $\M'$, we have
\begin{enumerate}
\item
$\M\mkpair \M', \sigma \models \A$\ or\ $\M\mkpair \M', \sigma \models \neg\A$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma \models \A$ and $\M\mkpair \M', \sigma  \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \vee \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma  \models \A$ or  $\sigma \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \neg\A$ never holds.
\item
$\M\mkpair \M', \sigma  \models \A$ and  $\M\mkpair \M', \sigma  \models \A \rightarrow \A'$  implies
$\M\mkpair \M', \sigma  \models \A '$.
\end{enumerate}
\end{lemma}
\begin{proof} By application of the corresponding definitions from \ref{def:valid:assertion}.\end{proof}.

\begin{lemma}[Assertions are classical-2]
For     assertions $\A$, $\A'$, and $\A''$ the following equivalences hold
\label{lemma:basic_assertions_classical}
\begin{enumerate}
\item
$ \A \wedge\neg \A \ \equiv \  \prg{false}$
\item
$ \A \vee \neg\A   \ \equiv \  \prg{true}$
\item
$ \A \wedge \A'  \ \equiv \  \A' \wedge \A$
\item
$ \A \vee \A'  \ \equiv \  \A' \vee \A$
\item
$(\A \vee \A') \vee \A'' \ \equiv \  \A \vee (\A' \vee\A'')$
\item
$(\A \vee \A') \wedge \A'' \ \equiv \  (\A \wedge \A')\, \vee\, (\A \wedge \A'')$
\item
$(\A \wedge \A') \vee \A'' \ \equiv \  (\A \vee \A')\, \wedge\, (\A \vee \A'')$
\item
$\neg (\A \wedge \A') \  \ \equiv \  \neg  \A   \vee\, \neg \A''$
\item
$\neg (\A \vee \A') \  \ \equiv \  \neg  \A   \wedge\, \neg \A''$
\item
$\neg (\exists \prg{x}.\A )  \  \ \equiv \  \forall \prg{x}.(\neg  \A)$
\item
$\neg (\exists k:\mathbb{N}.\A )  \  \ \equiv \  \forall  k:\mathbb{N}.(\neg  \A)$
\item
$\neg (\exists \prg{fs}:FLD^k.\A )  \  \ \equiv \  \forall \prg{fs}:FLD^k.(\neg  \A)$
\item
$\neg (\forall \prg{x}. \A)  \  \ \equiv \  \  \exists \prg{x}.\neg(\A )$
\item
$\neg (\forall k:\mathbb{N}. \A)  \  \ \equiv \  \  \exists k:\mathbb{N}.\neg(\A )$
\item
$\neg (\forall \prg{fs}:FLD^k. \A)  \  \ \equiv \  \  \exists \prg{fs}:FLD^k.\neg(\A )$
\end{enumerate}
\end{lemma}
\begin{proof}
All points follow by application of the corresponding definitions from \ref{def:valid:assertion}.
 \end{proof}

Notice that satisfaction is not preserved with growing configurations; for example, the assertion $\forall \x. [\ \x : \prg{Purse} \rightarrow \x.\prg{balance}>100\ ]$ may hold in a smaller configuration, but not hold in an extended configuration. Nor is it preserved with configuratio s getting smaller; consider \eg $\exists \x. [\ \x : \prg{Purse} \wedge \x.\prg{balance}>100\ ]$

% \begin{definition}
%We say that $\sigma \vdash \A$ if for any  \x\, is free in $\A$ and any
%  any term $\x.\f_1...\f_n$ appearing in $\A$,
% the interpretation $\interp{\x.\f_1...\f_n} \sigma$ is defined.
%\end{definition}
%
%Note that if we take $n=0$ in the definition above we obtain as corollary that   all variables that appear free in $\A$ they  are in the domain of the top frame in $\sigma$.
%
%\begin{lemma}[Preservation of satisfaction] $ $
%\label{lemma:preserve:valid}
%\begin{itemize}
%\item
%If  $\sigma \vdash \A$ and $\M\mkpair \M',  \sigma \vdash \A$ and   $\sigma' \subconf \sigma$, \  then  \ $\M\mkpair \M',  \sigma' \models \A$.
%\end{itemize}
%\end{lemma}

Finally, we define satisfaction of assertions by modules: A module $\M$ satisfies an assertion $\A$ if for all modules $\M'$, in all configurations arising from executions of $\M\mkpair\M'$, the assertion $\A$ holds.

\begin{definition}
\label{def:module_satisfies}
For any module $\M$, and  assertion $\A$, we define:
\begin{itemize}
\item
$\M \models \A$ \IFF  $\forall \M'.\, \forall \sigma\!\in\!\Arising{\M\mkpair\M'}.\   \M\mkpair\M', \sigma \models \A$
\end{itemize}
\end{definition}

The next sections contain full details. Section~\ref{sect:LangOO} defines a small oo language,  \LangOO, in terms of its  syntax, the structure of its runtime configurations $\sigma$, and its operational semantics in terms of a judgment with   the form $\M \mkpair \M', \sigma \leadsto \sigma'$. Section \ref{sect:assertions} gives the full definition of assertions $\A$,   when assertions are valid in given runtime configurations in terms of a judgment with   the form $\M \mkpair \M', \sigma \models \A$, and finally defines modules' adherence to assertions  in terms of a judgment with   the form $\M \models \A$.


