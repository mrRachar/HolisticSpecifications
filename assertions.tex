We now define the syntax and semantics of expressions and holistic assertions.
Expressions appear in assertions and support conditionals, comparisons, field read, as well as ghost field read.
Ghost fields allow us to define functions, including recursive ones, and use them in expressions, and thus also in
assertions.


 \subsection{Syntax of Assertions}

\begin{definition}[Assertions] The syntax of   expressions $(\SE)$ and assertions $(\A)$ is:
\label{def:assertions}

 $\begin{array}{lcl}
  ~  \\
 \SE  &\BBC&    \kwN{true}   ~\SOR~  \kwN{false}   ~\SOR~  \kwN{null}  ~\SOR~  \x  \   ~\SOR~  
     \   \SE=\SE    ~\SOR~ \kwN{if}\, \SE\,   \kwN{then}\,  \SE\,    \kwN{else}\, \SE    ~\SOR~  \SE.\f\lp\ \SE^* \ \rp\\
     \\
 \A &\ \BBC   &   \SE \   \mid \  \SE=\SE  \mid \   \SE:\prg{ClassId}  \ \mid \
    \SE\in\prg{S}   \mid  \  \\
    & &  \A \rightarrow \A  \ \mid\  \     \A \wedge \A  \ \mid\  \ \A \vee \A  \ \mid\  \ \neg A   \ \mid \  \forall \x.\A  \ \mid \  \forall \prg{S}:SET.\A  \ \mid  \  \exists \x.\A  \ \mid \  \exists \prg{S}:SET.\A  \  \ \mid\   \\
 &    & \External x   \ \mid\   \CanAccess x y \ \mid\  \ \Changes e \ \mid\  \Calls {\prg{x}}  {\prg{m}} {\prg{x}}  {\prg{x}^*} \ \mid\  \\  
 &    &  \Next \A  \ \mid \   \Future \A \ \mid \  \Prev \A    \ \mid \  \Past \A \\
 \\
 \x, \f, \m &\BBC&  \prg{Identifier}  ~ \\
\end{array}$
\end{definition}
%% \footnote{
%% The operators $\wedge$, $\vee$,  $\neg$ and $\forall$  could have been
%% defined  through the usual shorthands, \eg, $\neg \A$ is short for
%% $\A \rightarrow \ff$ \etc, but here we give full definitions
%% instead\kjx{can we just cut this please?}}
 

Assertions reflect over the contents of the current configuration but also over the possible 
past and future configurations.
We break the definition of validity into four parts:
Def.~\ref{def:valid:assertion:basic} % as we say Def. in other places too
describes validity
 of basic assertions (\ie those reflecting over the current configuration),
 Def.~\ref{def:valid:assertion:logical} describes  validity
 of assertions with logical connectives and quantifiers, 
Defs~\ref{def:valid:assertion:space} and \ref{def:valid:assertion:using} 
describe  validity involving space and control, and Def.~\ref{def:valid:assertion:time} describes  validity involving time.
% SD perhaps we do not need
% As has been discussed, validity of assertions has the format $\M\mkpair \M', \sigma \models \A$.



\subsection{Values of Expressions}
\label{sect:expressions}

The value  of  an expression  is described through judgment $ \M,\, \sigma, \SE \ \hookrightarrow\  v$,
defined in  Figure \ref{fig:ValueSimpleExpressions}.
We use the configuration, $\sigma$, to read the contents of the top stack frame
% value of variables defined in the stack frame
(rule ${\sf {Var\_Val}}$) or the contents of the heap (rule
${\sf {Field\_Heap\_Val}}$). We use the module, \M, to find the  ghost filed declaration corresponding to the
ghost field being used. 



The treatment of fields and ghost fields is described in rules ${\sf {Field\_Heap\_Val}}$,  ${\sf {Field\_Ghost\_Val}}$ and 
${\sf {Field\_Ghost\_Val2}}$.  If the field \f~ exists in the heap, then its value is returned (${\sf {Field\_Heap\_Val}}$). 
Ghost field reads, on the other hand, have the form $\e_0.\f(\e_1,...\e_n)$, and their value is
described in rule ${\sf {Field\_Ghost\_Val}}$:
%
The lookup function $\mathcal G$  (defined in the obvious way in the Appendix, Def.\ref{def:lookup})
returns the expression constituting the body for that ghost field, as defined in the class of $\e_0$.
We return  that expression
evaluated in a configuration where the formal parameters have been substituted by the values of the actual
parameters.


Ghost fields support recursive definitions. For example, imagine a class \prg{Node} 
which has a field called \prg{next}, and which 
had a ghost field \prg{last}, 
defined as \\
$~ \strut \hspace{.1cm}$ \ \ \ \prg{if}\ \ \prg{this.next}=\prg{null}\  \prg{then} \ \prg{this} \ \prg{else} \ \prg{this.next.last},\\
and another ghost field \prg{acyclic}, 
defined as \\
$~ \strut \hspace{.1cm}$ \ \ \ \prg{if}\ \ \prg{this.next}=\prg{null}\  \prg{then} \ \prg{true} \ \prg{else} \ \prg{this.next.acyclic}.\\
These are  recursive definitions, which allows us to find the last \prg{Node} in a sequence, or to express that
a sequence has no cycle.


Notice that $ \hookrightarrow$ is partial. For example, assume a module $\M_0$ with
a class \prg{Node} as described above, and  a configuration
$\sigma_0$ where
\prg{acyc} points to a \prg{Node} whose field \prg{next} has value \prg{null}, and   
\prg{cyc} points to a \prg{Node} whose field \prg{next} has the same value as \prg{cyc}. Then,   
$\M_0,\sigma_0,\,\prg{acyc.acyclic}  \ \hookrightarrow\  \prg{true}$, but we would have no value for 
$\M_0,\sigma_0,\, \prg{cyc.last}  \ \hookrightarrow\  ...$, nor for
$\M_0,\sigma_0,\, \prg{cyc.acyclic}  \ \hookrightarrow\  ...$.

Notice also that for an expression of the form  
\prg{\e.\f}, both ${\sf {Field\_Heap\_Val}}$ and ${\sf {Field\_Ghost\_Val2}}$ could be applicable: rule ${\sf {Field\_Heap\_Val}}$
will be applied if \prg{f} is a field of the object at \prg{e}, while rule ${\sf {Field\_Ghost\_Val}}$
will be applied if \prg{f} is a ghost field of the object at \prg{e}. We expect the set of fields and ghost fields in a 
given class to be disjoint.
This allows a specification to be agnostic over whether a field is a physical field or just ghost information.
For example, assertions (1) and (2) from section  \ref{sect:motivate:Bank} talk about the \prg{balance} of an \prg{account}. 
In the first version of the implementation, where we keep the balances in the account objects, this is a physical field. 
In the second version of the implementation, where we keep the
balances in a ledger, this is ghost information. More details in Appendix~\ref{Bank:appendix}.
 


\begin{figure*}
{$\begin{array}{l}
\begin{array}{llll}
\inferenceruleN {True\_Val} {
}
{
 \M,\, \sigma, \kwN{true} \ \hookrightarrow\  \kwN{true}
}
& 
\inferenceruleN {False\_Val} {
}
{
 \M,\, \sigma, \kwN{false} \ \hookrightarrow\  \kwN{false}
}
&
\inferenceruleN  {Null\_Val} {
}
{
 \M,\, \sigma, \kwN{null} \ \hookrightarrow\  \kwN{null}
}
&
\inferenceruleN {Var\_Val} {
}
{
 \M,\,  \sigma, \x \ \hookrightarrow\   \sigma({\x})
}
\end{array}
\\ \\
\begin{array}{lll}
\begin{array}{l}
\inferenceruleNM{Field\_Heap\_Val} {
 \M,\,  \sigma, \SE \ \hookrightarrow\   \alpha \hspace{1.5cm} 
 \sigma(\alpha,\f)=v
}
{
 \M,\, \sigma, \SE.\f  \ \hookrightarrow\   v
}
\\
\\
\inferenceruleNM{Field\_Ghost\_Val2} {
 \M,\, \sigma, \SE.\f \lp \rp \ \hookrightarrow\   v
}
{
 \M,\, \sigma, \SE.\f   \ \hookrightarrow\   v
}
\end{array}
& &
\inferenceruleNM{Field\_Ghost\_Val}
{
~ \\
 \M,\, \sigma, \SE_0   \ \hookrightarrow\  \alpha
\\
 \M,\, \sigma, \SE_i  \ \hookrightarrow\   v_i\ \ \ \ i\in\{1..n\}
 \\
{\mathcal{G}}
(\M, {\ClassOf {\alpha} {\sigma}}, {\f}) \  =  
\ \f\lp \p_1, \ldots \p_n \rp \lb\ \SE \ \rb
  \\
  \M,\,\sigma[\p_1\mapsto v_1, .... \p_n\mapsto v_n], \SE    \hookrightarrow_{\SAF}\   v 
 }
{
 \M,\,  \sigma, \ \SE_0.\f \lp \SE_1,....\SE_n\rp \hookrightarrow   \ v
}
\\ \\
\inferenceruleNM{If\_True\_Val} 
{
 \M,\,  \sigma, \SE \ \hookrightarrow\   \prg{true}  \\
   \M,\,  \sigma, \SE_1 \ \hookrightarrow\   v  
}
{
 \M,\, \sigma, \kwN{if}\ \SE\  \kwN{then} \ \SE_1 \ \kwN{else} \ \SE_2\  \hookrightarrow  \ v
}
& &
\inferenceruleNM {If\_False\_Val} 
{
 \M,\,  \sigma, \SE \ \hookrightarrow\   \prg{false}  \\
   \M,\,  \sigma, \SE_2 \ \hookrightarrow\   v  }
{
 \M,\, \sigma, \kwN{if}\ \SE\  \kwN{then} \ \SE_1 \ \kwN{else} \ \SE_2\  \hookrightarrow\  v
}
\\ \\ 
\inferenceruleNM {Equals\_True\_Val} 
{
 \M,\,  \sigma, \SE_1 \ \hookrightarrow\    v \\
   \M,\,  \sigma, \SE_2 \ \hookrightarrow\     v 
}
{
 \M,\, \sigma, \SE_1 =  \SE_2 \hookrightarrow \prg{true}
}
& &
\inferenceruleNM {Equals\_False\_Val} 
{
 \M,\,  \sigma, \SE_1 \ \hookrightarrow\    v \\
   \M,\,  \sigma, \SE_2 \ \hookrightarrow\     v' \hspace{2cm}  v\neq v'
}
{
 \M,\, \sigma, \SE_1 =  \SE_2 \hookrightarrow \ \prg{false}
}
\end{array}
\end{array}
$}
\caption{Value of  Expressions}
\label{fig:ValueSimpleExpressions}
\end{figure*}

\subsection{Satisfaction of Assertions - standard}


 \begin{definition}[Interpretations for simple expressions]

For a runtime configuration, $\sigma$,   and a variable, $\x$, we define its interpretation as follows:

\begin{itemize}
  \item
  $\interp {\x}{\sigma}$ $ \triangleq$ $\phi(\x)$  \ \ if \ \ $\sigma$=$(\phi\cdot\_,\_)$
  \item
   $\interp {\x.\f}{\sigma}$ $ \triangleq$ $\chi(\interp {\x}{\sigma},\f)$  \ \ if \ \ $\sigma$=$(\_,\chi)$
   \end{itemize}
\end{definition}   

 
\begin{definition}[ Basic Assertions] For modules $\M$, $\M'$,  configuration $\sigma$,  we define
validity of basic assertions: \label{def:valid:assertion:basic}
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models\SE$ \IFF   $ \M,\,  \sigma, \SE \ \hookrightarrow\   \prg{true}$ 
\item
$\M\mkpair \M', \sigma \models\SE=\SEPrime$ \IFF there exists a value $v$ such that  $\M,\,  \sigma, \SE \ \hookrightarrow\   v$  and $ \M,\,  \sigma, \SEPrime \ \hookrightarrow\   v$.
           \item
$\M\mkpair \M', \sigma \models\SE:\prg{ClassId}$ \IFF there exists an address $\alpha$ such that \\
$\strut ~ $ \hspace{2in} \hfill   
 $ \M,\,  \sigma, \SE \ \hookrightarrow\   \alpha$, and $\ClassOf{\alpha}{\sigma}$ = \prg{ClassId}.
\item
$\M\mkpair \M', \sigma \models \SE\in \prg{S}$ \IFF there exists a value $v$ such that 
 $ \M,\,  \sigma, \SE \ \hookrightarrow\   v$, and $v \in \interp{\prg{S}}{\sigma}$.
\end{itemize}
\end{definition}

Note that satisfaction of assertions which contain expressions is predicated on termination of these expressions.
Continuing our earlier example,  
$\M_0\mkpair \M', \sigma_0 \models \prg{acyc.acyclic}$ holds for any $\M'$, while $\M_0\mkpair \M', \sigma_0 \models \prg{cyc.acyclic}$
does not hold, and $\M_0\mkpair \M', \sigma_0 \models \prg{cyc.acyclic}=\prg{false}$ does not hold either.
In general, when $\M\mkpair \M', \sigma  \models \prg{e}$ holds,  this implies that $\M\mkpair \M', \sigma  \models \prg{e}=\prg{true}$ holds too.
But when $\M\mkpair \M', \sigma  \models \prg{e}$ does not hold, this does \emph{not} imply that $\M\mkpair \M', \sigma  \models \prg{e}=\prg{false}$ holds.
Finally, an assertion of the form $\e_0=\e_0$ does not necessarily hold; for example,   $\M_0\mkpair \M', \sigma_0 \models \prg{cyc.last}=\prg{cyc.last}$ does not hold.

% \subsubsection{Logical connectives, quantifiers, space and control} 
We now define satisfaction of assertions which involve logical connectives and existential or universal quantifiers.

\begin{definition}[Assertions with logical connectives and quantifiers]  
%We now consider 
\label{def:valid:assertion:logical}
For modules $\M$, $\M'$, assertions $\A$, $\A'$, variables \prg{x}, \prg{y}, \prg{S},  and configuration $\sigma$, we define$:$
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models \forall \prg{S}:\prg{SET}.\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
$\strut ~ $ \hfill for all sets of addresses $R\subseteq dom(\sigma)$, and  all \prg{Q} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}\!.\,\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
 $\strut ~ $ \hfill  for some set of addresses $R\subseteq dom(\sigma)$, and   \prg{Q} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \forall \prg{x}.\A$ \IFF
$\sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$ \ for all  $\alpha\in dom(\sigma)$, and  some \prg{z} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \exists \prg{x}.\A$ \IFF
$\M\mkpair \M', \sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$\\
$\strut ~ $ \hfill for some  $\alpha\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \A \rightarrow \A' $ \IFF  $\M\mkpair \M', \sigma \models \A $ implies $\M\mkpair \M', \sigma \models \A' $
\item
$\M\mkpair \M', \sigma \models  \A \wedge \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
and $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \A \vee \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
or $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \neg\A$   \IFF  $\M\mkpair \M', \sigma \models  \A $
does not hold.
\end{itemize}
\end{definition}

\noindent
Again, with our earlier example,  
$\M_0\mkpair \M', \sigma_0 \models \neg (\prg{cyc.acyclic}=\prg{true})$    and  
$\M_0\mkpair \M', \sigma_0 \models  \neg (\prg{cyc.acyclic}=\prg{false})$, 
and also 
$\M_0\mkpair \M', \sigma_0 \models  \neg (\prg{cyc.last}=\prg{cyc.last})$
hold.



\subsection{Satisfaction of Assertions - Access, Control, Space, Viewpoint}
%\subsubsection{Space and Contol} 
We now consider the assertions which involve access:

\begin{definition}[%Satisfaction of  Assertions about 
Access]  \label{def:valid:assertion:access}
For any modules $\M$, $\M'$,  variables \prg{x} and \prg{y}, we define
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models  \CanAccess{\prg{x}}{\prg{y}}$   \IFF  \begin{itemize}
\item
$\interp {\x} {\sigma}$=$\interp {\y} {\sigma}$, \ \ or
\item
$\interp {\x.\f} {\sigma}$=$\interp {\y} {\sigma}$, \  \ for some field \prg{f},  \ \ or
\item
$\interp {\x} {\sigma}$=$\interp {\this} {\sigma}$ and
  $\interp {\y} {\sigma}$=$\interp {\z} {\sigma}$,\ \ \ 
for some variable \z. where  \z\ appears in  $\sigma$.\prg{contn}.
 \end{itemize}
\end{itemize}
\end{definition}

\noindent 
Therefore, $\CanAccess{\prg{x}}{\prg{y}}$ expresses that \x\, has a {\em direct} path to \y.
It says that in the current frame,
either \x~and \y\ are  aliases, or \x~points to an object which has a field
whose value is the same as that of \y, or \x\, is the currently executing object and \y\, is
 a local variable or formal parameter \z\,which appears in the code in the continuation ($\sigma$.\prg{contn}).
The latter requirement ensures that variables which were introduced into the variable map,
in order to give meaning to existentially quantified assertions, are not considered.


\begin{definition}[%Satisfaction of  Assertions about 
Control]  \label{def:valid:assertion:control}
For any modules $\M$, $\M'$,  variables \prg{x} and  \y,  sequences of variables, $\prg{z}_1,...\prg{z}_n$, we define$:$
\begin{itemize}
   \item
$\M\mkpair \M', \sigma \models  \Calls {\prg{x}}  {\prg{m}} {\prg{y}}  {\z_1,...\z_n}$ \IFF \
 $\sigma.\prg{contn}$=${\uu.\m(\v_1,..\v_n);\_}$,\ \ \ for some  \uu\, and $\v_1$,... $\v_n$.
\\ $\strut ~ \hspace{2.1in} $
and $\interp{\prg{this}}{\sigma}$=$\interp{\prg{x}}{\sigma}$, \ and\ $\interp{\prg{y}}{\sigma}$=$\interp{\prg{u}}{\sigma}$,
\\ $\strut ~ \hspace{2.1in} $
and  $\interp{\z_i}{\sigma}$=$\interp{\prg{v}_i}){\sigma}$, for all \ $i$.
 \end{itemize}
\end{definition}
\noindent 
Thus,  $\Calls {\prg{x}}  {\prg{m}} {\prg{y}}  {{\z_1,...\z_n}}$ expresses that the next action will be the method call 
$\y.\m(\z_1,...\z_n)$ and that the caller is \x. 
 
 \begin{definition}[%Satisfaction of  Assertions about 
Viewpoint]  \label{def:valid:assertion:space}
For any modules $\M$, $\M'$, and variable\x, we define
\begin{itemize}
 \item
$\M\mkpair \M', \sigma \models \External {\x}$ 
  \IFF
 $\ClassOf {\interp{\x}{\sigma}} {\sigma} \notin dom(\M)$
\item
$\M\mkpair \M', \sigma \models \Internal {\x}$ 
  \IFF
 $\ClassOf {\interp{\x}{\sigma}} {\sigma} \in dom(\M)$
\end{itemize}
\end{definition}
\noindent 
Whether a variable is external depends on the \kjx{module of its
defining class.}
 
\james{moved to here, should this be a def?}
Finally, an assertion of the form $\Using{A}{S}$ promises that $\A$ holds in a subconfiguration, whose heap is restricted to the objects from \prg{S}.
That is, $\sigma\!\!\downarrow_{\sigma(\prg{S})}$ is the same as $\sigma$ but with the domain of the heap restricted
 to the addresses from $\sigma(\prg{S})$. And then we define\\
   $~ \strut  \hspace{1.3in} \M \mkpair  {\M'},\sigma  \models\Using {\A} {\prg{S}}$\ \ \ \ \ if \ \ \ \  \  $\M \mkpair  {\M'},\sigma\!\!\downarrow_{\sigma(\prg{S})}  \models {\A}$



\begin{definition}[%Satisfaction of  Assertions about 
Space and Restriction of Runtime Configurations]  \label{def:valid:assertion:space} \label{def:restrict}
For any modules $\M$, $\M'$, assertions $\A$ and variable \prg{S}, we define$:$
\begin{itemize}
\item
 $\M\mkpair \M', \sigma \models \Using {\A} {\prg{S}}$
 \IFF
 $\M\mkpair \M', \restrct \sigma {\prg{S}} \models  \A  $.
\end{itemize}
The restriction operator~$\;\restrct{} {} $ applied to a runtime configuration $\sigma$ and a variable  \prg{S} is defined as follows:
 \label{def:config:restrct}
 $~ $
\begin{itemize}
\item
$\restrct {\sigma}{\prg{S}} \ \triangleq \ (\sd{\psi}, \chi')$, \IFF  $\sigma$=$(\psi,\chi)$, \ and  \  $dom(\chi')=\interp {\prg{S}} {\sigma}$, and   
% \\ $\ \strut \ \ \hspace{1.2in} $
 $\forall \alpha\!\in\!dom(\chi').\chi(\alpha)=\chi'(\alpha)$
\end{itemize}
\end{definition}
\noindent 
TODO explain 

 
 
 
\susan{is this okay?}]\james{I Think so, would like more on why}\sophia{what are you talking abouy.}
TO REVISIT Perhaps $\Using {\A} {\prg{S}}$ is the most intriguing of our holistic assertions. $\Using {\A} {\prg{S}}$ allows us to restrict the set of objects that need to be considered when testing an assertion.

\subsection{Satisfaction of Assertions - Time}
 Finally, we  consider assertions involving time. 
 \susan{not sure whether I got this right}
 To do this, we need  an  auxiliary concept:
$\adapt$, the adaptation of one runtime configuration to the scope  
of another. This operator is needed in changes of scope during execution. For example, the assertion
$\Future {\x.\f=\prg{3}}$  is satisfied in the \emph{current} configuration % $\sigma$,
 if in some {\em future} configuration the field  \f\, of the object that is pointed at 
 by \x\, in the {\em current} configuration has the value \prg{3}.

 % That is, $\Future {\x.\f=\prg{3}}$  is satisfied in $\sigma$, if there exists a $\sigma'$ in the future of $\sigma$ such that
% $\sigma'[\prg{z}\mapsto\interp \sigma
 Note that in the future  configuration, \x\, may be pointing to a different object, or may
even no longer be in scope (\eg if a nested call  is executed).
Therefore, we introduce the operator \  $\adapt\;$,  \ which combines runtime configurations: $\sigma \adapt \sigma'$ adapts the second configuration to the top frame's view of the former: it returns a new configuration whose stack has  the top frame as taken from $\sigma$ and where the \prg{contn} has been consistently renamed, while the heap is taken from $\sigma'$. This allows us to interpret expressions  in the newer (or older) configuration $\sigma'$ but with the variables bound according to the top frame from $\sigma$; \eg we can obtain that value of \prg{x} in configuration  $\sigma'$ even if \prg{x} was out of scope. The consistent renaming of the code allows the correct modelling of execution (as needed,   for the semantics of  nested time assertions, as \eg in $\Future {\x.\f=\prg{3} \wedge \Future {\x.\f=\prg{5}}}$



 \begin{definition}[Adaptation  of Runtime Configurations]   \label{def:config:adapt}
 For runtime configurations $\sigma$, $\sigma'$.$:$
 $~ $ 

\begin{itemize}
\item
$\sigma \adapt \sigma' \triangleq (\phi''\cdot\psi',\chi')$  \IFF $\sigma=(\phi\cdot\_,\_)$, and $\sigma'= (\phi'\cdot\psi',\chi')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $
$\phi$=$(\prg{contn},\varMap)$, and $\phi'$=$(\prg{contn}',\varMap')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $     % $\phi''$ such that
  $\phi''=(\, \prg{contn}'[\prg{zs}/\prg{zs}' ],\,\varMap[\prg{zs}'\mapsto \varMap'(\prg{zs})]\, ) $, where
 \\
$\ \strut \ \ \hspace{1.45in} $
\prg{zs}=$dom(\varMap)$, and
 \\
$\ \strut \ \ \hspace{1.45in} $      $\prg{zs}'$ is a set  of variables with  the  same cardinality as \prg{zs}, and
 \\
$\ \strut \ \ \hspace{1.45in} $   all variables in
$\prg{zs}'$  are fresh in $\varMap$ and in $\varMap'$.
\end{itemize}
\end{definition}

That is, in the new frame $\phi''$ from above, we keep the same continuation as from $\sigma'$ but rename all
variables with fresh names $prg{zs}'$, and in the variable map we comnine that from $\sigma$ and $\sigma'$
but avoid names clashes through the renaming $[\prg{zs}'\mapsto \varMap'(\prg{zs})]$.
With this auxiliary definition, we can now define satisfaction of assertions which involve time:


\begin{definition}[Assertions over Time]  \label{def:valid:assertion:time}
For any modules $\M$, $\M'$, assertions $\A$, $\A'$, variables \prg{x} and \prg{S}, we define
  
\begin{itemize}
 \item
 $\M\mkpair \M', \sigma \models   \Changes{\prg{e}}$  \IFF
 $\exists \sigma'.\, [\ \ \M\mkpair \M',\sigma \leadsto \sigma' \ \wedge \interp{e}{\sigma} \neq \interp{e}{\sigma\triangleleft \sigma'} \ \  ]$.
 \item
  $\M\mkpair \M', \sigma \models  \Next \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto  \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is
so that $\sigma$=$(\phi\cdot\_,\_)$.\item
  $\M\mkpair \M', \sigma \models  \Future \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto^* \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is
so that $\sigma$=$(\phi\cdot\_,\_)$.  
  \item
 $\M\mkpair \M', \sigma \models  \Prev \A $ \IFF
 $\forall \sigma_1, \sigma_2. [\ \ \Initial{\sigma_1}\ \wedge \   \M\mkpair \M', \sigma  \leadsto^*  \sigma_2 \ \wedge \   \M\mkpair \M', \sigma_2  \leadsto   \sigma  
$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \   
 \M\mkpair \M', \sigma\adapt\sigma_2  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
 \item
 $\M\mkpair \M', \sigma \models  \Past \A $ \IFF
 $\forall \sigma_1, ... \sigma_n. [\ \ \Initial{\sigma_1}\ \wedge \  \sigma_n=\sigma 
  \ \wedge \ \forall i\in[1..n). \M\mkpair \M', \sigma_{i} \leadsto  \sigma_{i+1}
$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \  \exists j\in [1..n-1).
 \M\mkpair \M', \sigma\adapt\sigma_j  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
\end{itemize}
\end{definition}

Thus,  $\M\mkpair \M', \sigma \models  \Future \A $ holds if
$\A$ holds in some configuration $\sigma'$ which arises from execution of $\phi$, where $\phi$ is the top frame of $\sigma$. By requiring that $\phi \leadsto^* \sigma' $ rather than
$\sigma \leadsto^* \sigma' $ we are restricting the set of possible future configurations to
just those that are caused by the top frame;
that is, we do not want to consider the effect of  enclosing function calls.

This allows us to write more natural specifications
when giving necessary conditions for some future effect.
 

\subsection{Entailment and Equivalence}
 
We define equivalence of   assertions in the usual sense: two assertions are equivalent if they are satisfied  in
the context of the same configurations.
Similarly, an assertion entails another assertion, iff all configurations 
which satisfy the former also satisfy the latter.  

\begin{definition}[Equivalence and entailments of assertions]
$ ~ $

\begin{itemize}
\item
$\A \equiv \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ if and only if }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\item
$\A \subseteqq \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ implies }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\end{itemize}
\end{definition}



\begin{lemma}[Assertions are classical-1]
For all runtime configurations $\sigma$,    assertions $\A$ and $\A'$, and modules $\M$  and $\M'$, we have
\begin{enumerate}
\item
$\M\mkpair \M', \sigma \models \A$\ or\ $\M\mkpair \M', \sigma \models \neg\A$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma \models \A$ and $\M\mkpair \M', \sigma  \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \vee \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma  \models \A$ or  $\sigma \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \neg\A$ never holds.
\item
$\M\mkpair \M', \sigma  \models \A$ and  $\M\mkpair \M', \sigma  \models \A \rightarrow \A'$  implies
$\M\mkpair \M', \sigma  \models \A '$.
\end{enumerate}
\end{lemma}
\begin{proof} By application of the corresponding definitions from \ref{def:valid:assertion:logical}.\end{proof}.
 \susan{ I have put the logic definition in to the proofs these two lemmas - please confirm}
\begin{lemma}[Assertions are classical-2]
For     assertions $\A$, $\A'$, and $\A''$ the following equivalences hold
\label{lemma:basic_assertions_classical}
\begin{enumerate}
\item
$ \A \wedge\neg \A \ \equiv \  \prg{false}$
\item
$ \A \vee \neg\A   \ \equiv \  \prg{true}$
\item
$ \A \wedge \A'  \ \equiv \  \A' \wedge \A$
\item
$ \A \vee \A'  \ \equiv \  \A' \vee \A$
\item
$(\A \vee \A') \vee \A'' \ \equiv \  \A \vee (\A' \vee\A'')$
\item
$(\A \vee \A') \wedge \A'' \ \equiv \  (\A \wedge \A')\, \vee\, (\A \wedge \A'')$
\item
$(\A \wedge \A') \vee \A'' \ \equiv \  (\A \vee \A')\, \wedge\, (\A \vee \A'')$
\item
$\neg (\A \wedge \A') \  \ \equiv \  \neg  \A   \vee\, \neg \A''$
\item
$\neg (\A \vee \A') \  \ \equiv \  \neg  \A   \wedge\, \neg \A''$
\item
$\neg (\exists \prg{x}.\A )  \  \ \equiv \  \forall \prg{x}.(\neg  \A)$
\item
$\neg (\exists k:\mathbb{N}.\A )  \  \ \equiv \  \forall  k:\mathbb{N}.(\neg  \A)$
\item
$\neg (\exists \prg{fs}:FLD^k.\A )  \  \ \equiv \  \forall \prg{fs}:FLD^k.(\neg  \A)$
\item
$\neg (\forall \prg{x}. \A)  \  \ \equiv \  \  \exists \prg{x}.\neg(\A )$
\item
$\neg (\forall k:\mathbb{N}. \A)  \  \ \equiv \  \  \exists k:\mathbb{N}.\neg(\A )$
\item
$\neg (\forall \prg{fs}:FLD^k. \A)  \  \ \equiv \  \  \exists \prg{fs}:FLD^k.\neg(\A )$
\end{enumerate}
\end{lemma}
\begin{proof}
All points follow by application of the corresponding definitions from \ref{def:valid:assertion:logical}.
 \end{proof}

 Notice that satisfaction is not preserved with growing configurations; for example, the assertion $\forall \x. [\ \x : \prg{Account} \rightarrow \x.\prg{balance}>100\ ]$ 
may hold in a smaller configuration, but not hold in an extended configuration. 
Nor is it preserved with configurations getting smaller; consider \eg $\exists \x. [\ \x : \prg{Account} \wedge \x.\prg{balance}>100\ ]$.


% \begin{definition}
%We say that $\sigma \vdash \A$ if for any  \x\, is free in $\A$ and any
%  any term $\x.\f_1...\f_n$ appearing in $\A$,
% the interpretation $\interp{\x.\f_1...\f_n} \sigma$ is defined.
%\end{definition}
%
%Note that if we take $n=0$ in the definition above we obtain as corollary that   all variables that appear free in $\A$ they  are in the domain of the top frame in $\sigma$.
%
%\begin{lemma}[Preservation of satisfaction] $ $
%\label{lemma:preserve:valid}
%\begin{itemize}
%\item
%If  $\sigma \vdash \A$ and $\M\mkpair \M',  \sigma \vdash \A$ and   $\sigma' \subconf \sigma$, \  then  \ $\M\mkpair \M',  \sigma' \models \A$.
%\end{itemize}
%\end{lemma}

Finally, we define satisfaction of assertions by modules: A module $\M$ satisfies an assertion $\A$ if for all modules $\M'$, in all configurations arising from executions of $\M\mkpair\M'$, the assertion $\A$ holds.

\begin{definition}
\label{def:module_satisfies}
For any module $\M$, and  assertion $\A$, we define:
\begin{itemize}
\item
$\M \models \A$ \IFF  $\forall \M'.\, \forall \sigma\!\in\!\Arising{\M\mkpair\M'}.\   \M\mkpair\M', \sigma \models \A$
\end{itemize}
\end{definition}



