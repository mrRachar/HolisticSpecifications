
%\section{ Assertions} 
%\label{sect:assertions}

%\subsection{The syntax of Expressions and Assertions}
We now define the syntax of  expressions and assertions.
%\secomment{if you like this I will write macros so as not to have parameter lists with the keywords, alternatively this list could just have the identifiers and no descriptions\sd{not clear what is meant}}
%In section~\ref{sect:chainmail} we introduced our assertion language \Chainmail with keywords 
%$\CanAccess{}{}$ to check whether one object can call another, $\Calls{}$ for the current function call, 
%$\Changes{}$ to check whether the next configuration will affect validity of some assertion, and 
% $\Next {}$ or $\Future {}$  for expressing an assertion will hold at
%the immediate successor execution point or at some future point, and
%$\Prev{}$ or $\Past{}$ to express  that an assertion held at the immediately previous or
%some point in the past, and  $\Using{}{}$, 
%for expressing that an assertion holds in
%the sub-configuration determined by a witness.
%
%The keywords enable \Chainmail assertions to support 
%reflection over various aspects of the current 
%runtime configurations, reflection over past or future configurations, and 
%reflection over sub-configurations.
%Assertions can contain logical operators and interestingly, the existential and universal quantifiers may quantify over object addresses, as well as 
%over sets of addresses, numbers, and sequences of field identifiers of a given length.
%
%
%\secomment{if you prefer this paragraph then link it back to section 4. \sd{Yes, it may now be superfluous.}}
%
%
%Assertions, $\A$, support standard logical operators, 
%reflection over various aspects of the current 
%runtime configurations, reflection over past or future configurations, and 
%reflection over sub-configurations.
%The standard logical operators are, unsurprisingly,
% $\wedge$, $\vee$, $\rightarrow$, $\neg$, $\exists$ and $\forall$.
%Interestingly, the existential and universal quantifiers may quantify over object addresses, but also 
%over sets of addresses, numbers, and sequences of field identifiers of a given length.
%When reflecting over the current state, we can reflect over the class and contents of objects
%(\eg \x:\prg{ClassId} or \x.\f=\y.\f'), whether an
%object has direct access to (and thus may call on) another object $\CanAccess{\_}{\_}$,
%and the current function call $\Calls{\prg{\_},\prg{\_},\prg{\_},\prg{\_}}$.
%We can also talk about whether the next configuration will affect the 
%validity of some assertion $\Changes{\_}$
%\footnote{Note that $\Changes{\_}$ may be encoded; do we keep it?
%The reason to keep it is that we can then talk of "permission" and "authority" }.  
%We also support {\em temporal} modifiers, where $\Next \A$ or $\Future \A$  express  that $\A$ will hold at
%the immediate successor execution point or at some future point, while
%$\Prev \A$ or $\Past \A$ express  that $\A$ held at the immediately previous or
%some point in the past.
%Finally, we support a {\em spatial modifier}, $\Using{\A}{S}$, 
%which expresses that assertion $\A$ holds in
%the sub-configuration determined by the witness \prg{S}.


\subsection{Syntax of Assertions}

\begin{definition}[Assertions] The syntax of   expressions ($\SE$) and assertions ($\A$) is:
\label{def:assertions}

 $\begin{array}{lcl}
  ~  \\
  \SE & ::= &  \prg{true}  \ \mid\ \prg{false}  \    \mid\ \prg{null}  \ \mid \ \x  \ \mid \ \SE.\f  \\  
 ~ \\
\A &\ ::=\  &   \SE \   \mid \  \SE=\SE  \mid \   \SE:\prg{ClassId}  \ \mid \
    \SE\in\prg{S}   \mid  \  \\
    & &  \A \rightarrow \A  \ \mid\  \     \A \wedge \A  \ \mid\  \ \A \vee \A  \ \mid\  \ \neg A   \ \mid \  \forall \x.\A  \ \mid \  \forall \prg{S}:SET.\A  \ \mid  \  \exists \x.\A  \ \mid \  \exists \prg{S}:SET.\A  \  \ \mid\   \\
 &    & \External x   \ \mid\   \CanAccess x y \ \mid\  \ \Changes e \ \mid\  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}} \ \mid\  \\  
 &    &  \Next \A  \ \mid \   \Future \A \ \mid \  \Prev \A    \ \mid \  \Past \A \ 
\end{array}$
\end{definition}
\footnote{
Note that the operators $\wedge$, $\vee$,  $\neg$ and $\forall$  could have been defined  through the usual shorthands, \eg, $\neg \A$ is short for
$\A \rightarrow \ff$ \etc, but here we give full definitions instead.\sd{SD: Perhaps we should just do that, it make the defs implicit}}


As we discussed in section \sd{TODO} validity of assertions has the format $\M\mkpair \M', \sigma \models \A$, where  $\M$ is the internal module, whose internal workings
 are opaque to the external, client module $\M'$.
 % We next define satisfaction of assertions in the context of an internal module \M, and externalk module $\M'$
%and a runtime configuration $\sigma$, in terms of the judgement $\M\mkpair \M', \sigma \models\A$.
 We break the definition into four parts: In definition  \ref{def:valid:assertion:basic} we define validity 
 of basic assertions which reflect over the contents of the frame or the heap. 
 In  definition  \ref{def:valid:assertion:logical} we define validity 
 of basic assertions which reflect over the contents of the frame or the heap. 

\subsection{Satsfaction of Assertions - standard}

% \subsubsection{Interpretations  and   Basic Assertions}

 \begin{definition}[Interpretations for simple expressions]

For any runtime configuration, $\sigma$, and any $k\in \mathbb{N}$, and any simple expression, $\SE$, we define its interpretation as follows:

\begin{itemize}
     \item
  $\interp {\prg{true}}{\sigma}$ $ \triangleq$   \prg{true}, \ and \ \    $\interp {\prg{false}}{\sigma}$ $ \triangleq$ \prg{false}, \ and \ \
   $\interp {\prg{null}}{\sigma}$ $ \triangleq$  \prg{null}
  \item
  $\interp {\x}{\sigma}$ $ \triangleq$ $\phi(\x)$  \ \ if \ \ $\sigma$=$(\phi\cdot\_,\_)$
  \item
  $\interp {\SE.\prg{f}}{\sigma}$ $ \triangleq$ $\chi({\interp {\SE}{\sigma}}, \prg{f})$  \ \ if \ \ $\sigma$=$(\_,\chi)$
   \end{itemize}
\end{definition}

\begin{lemma}[Interpretation corresponds to execution]
For any simple expression $\SE$, module $\M$,  runtime configuration $\sigma$, and value $v$:
\begin{itemize}
  \item
   $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M, \sigma[\prg{contn}\mapsto \SE] \leadsto v$ .
\end{itemize}
\end{lemma}
\begin{proof} by structural induction  over the definition of $\SE$.\end{proof}
   

\begin{definition}[ Basic Assertions] We define   when a configuration satisfies basic assertions, consisting of %simple
expressions.
 \label{def:valid:assertion:basic}
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models\SE$ \IFF  $\interp{\SE}{\sigma}$ = \prg{true}.
\item
$\M\mkpair \M', \sigma \models\SE=\SEPrime$ \IFF $\interp{\SE}{\sigma}$ = $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE:\prg{ClassId}$ \IFF $\ClassOf{\interp{\SE}{\sigma}}{\sigma}$ = \prg{ClassId}.
\item
$\M\mkpair \M', \sigma \models \SE\in \prg{S}$ \IFF $\interp{\SE}{\sigma}\in \interp{\prg{S}}{\sigma}$.
\end{itemize}
\end{definition}

% \subsubsection{Logical connectives, quantifiers, space and control} 
We now define satisfaction of assertions which involve logical connectives and existential or universal quantifiers.

\begin{definition}[Assertions with logical connectives and quantifies]  
We now consider \label{def:valid:assertion:logical}
For modules $\M$, $\M'$, assertions $\A$, $\A'$, variables \prg{x} and \prg{S},  configuration $\sigma$, we define$:$
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models \exists \prg{x}.\A$ \IFF
$\M\mkpair \M', \sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$\\
$\strut ~ $ \hfill for some  $\alpha\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \forall \prg{S}:\prg{SET}.\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
$\strut ~ $ \hfill for all sets of addresses $R\subseteq dom(\sigma)$, and  all \prg{Q} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}\!.\,\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
 $\strut ~ $ \hfill  for some set of addresses $R\subseteq dom(\sigma)$, and   \prg{Q} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \forall \prg{x}.\A$ \IFF
$\sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$ \ for all  $\alpha\in dom(\sigma)$, and  some \prg{z} free in $\sigma$ and $\A$.
\item
$\M\mkpair \M', \sigma \models \A \rightarrow \A' $ \IFF  $\M\mkpair \M', \sigma \models \A $ implies $\M\mkpair \M', \sigma \models \A' $
\item
$\M\mkpair \M', \sigma \models  \A \wedge \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
and $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \A \vee \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
or $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \neg\A$   \IFF  $\M\mkpair \M', \sigma \models  \A $
does not hold.
\end{itemize}
\end{definition}

\subsection{Satisfaction of Assertions - Space}
%\subsubsection{Space and Contol} 
And now, we consider the assertions which involve space and  control:

\begin{definition}[Satisfaction of  Assertions about Space-1]  \label{def:valid:assertion:space}
For any modules $\M$, $\M'$, assertions $\A$, $\A'$, variables \prg{x} and \prg{S}, we define
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models  \CanAccess{\prg{x}}{\prg{y}}$   \IFF  \begin{itemize}
\item
$\interp {\x} {\sigma}$=$\interp {\y} {\sigma}$, or
\item
$\interp {\x.\f} {\sigma}$=$\interp {\y} {\sigma}$  for some field \prg{f},  or
\item
$\interp {\x} {\sigma}$=$\interp {\this} {\sigma}$ and
  $\interp {\y} {\sigma}$=$\interp {\z} {\sigma}$,\ 
and \z\ appears in  $\sigma$.\prg{contn}.
 \end{itemize}
   \item
$\M\mkpair \M', \sigma \models  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}}$ \IFF \
 $\sigma.\prg{contn}$=\prg{u.m(v);\_}\ \ for some variables \prg{u} and \prg{v},  \ and \
\\ $\strut ~ \hspace{1.4in} $
$\interp{\prg{this}}{\sigma}$=$\interp{\prg{x}}{\sigma}$, \ and\ $\interp{\prg{y}}{\sigma}$=$\interp{\prg{u}}{\sigma}$,
 \ and\ $\interp{\prg{z}}{\sigma}$=$\interp{\prg{v}}{\sigma}$.
 \item
 $\M\mkpair \M', \sigma \models \Using {\A} {\prg{S}}$
 \IFF
 $\M\mkpair \M', \restrct \sigma {\prg{S}} \models  \A  $.
 \item
  \sd{$\M\mkpair \M', \sigma \models \External {\prg{e}}$}
  \IFF
$\sd{ {\ClassOf {\interp{\SE}{\sigma}}{\sigma}}\notin dom(\M)}$
\end{itemize}
\end{definition}
 
$\CanAccess{\prg{x}}{\prg{y}}$ expresses that \x\, has a {\em direct} path to \y.
It says that in the current frame,
either \x and \y\, are  aliases, or \x points to an object which has a field
whose value is the same as that of \y, or \x\, is the currently executing object and \y\, is
 a local variable or formal parameter \z\,which appears in the code in the continuation ($\sigma$.\prg{contn}).
The latter requirement ensusres that  that variables which were introduced into the variable map  
in order to give meaning to existentially quantified assertions are not considered.

On the other hand, an assertion of the form $\Using{A}{S}$ promises that $\A$ holds in subconfiguration, whose heap is restricted to the objects from \prg{S}.

 
 
\begin{definition}[Restriction of Runtime Configurations]   \label{def:restrict}
The restriction operator~$\;\restrct{} {} $ applied to a runtime configuration $\sigma$ and a set $R$ is defined as follows:
 \label{def:config:restrct}
 $~ $

\begin{itemize}
\item
$\restrct {\sigma}{\prg{S}} \ \triangleq \ (\sd{\psi}, \chi')$, \IFF  $\sigma$=$(\psi,\chi)$, \ and  \  $dom(\chi')=\interp {\prg{S}} {\sigma}$, and   
% \\ $\ \strut \ \ \hspace{1.2in} $
 $\forall \alpha\!\in\!dom(\chi').\chi(\alpha)=\chi'(\alpha)$
 \sdcomment{I had written instead $[ \ClassOf {\alpha} {\chi'} =  \ClassOf {\alpha} {\chi}\ \wedge \ \forall \f.  \chi'(\alpha,\f)=\chi(\alpha,\f)\ ]$, but I do not see why}
\end{itemize}
\end{definition}

\begin{definition}[Satisfaction of  Assertions about Space-2]  \label{def:valid:assertion:using}
For any modules $\M$, $\M'$, assertion  $\A$, set variable \prg{S},  and configuration $\sigma$, we define
\begin{itemize}
 \item
 $\M\mkpair \M', \sigma \models \Using {\A} {\prg{S}}$
 \IFF
 $\M\mkpair \M', \restrct \sigma {\prg{S}} \models  \A  $.
\end{itemize}
\end{definition}

Perhaps $\Using {\A} {\prg{S}}$ is the most intriguing of our holistic assertions. It allows us to restrict the set of objects that are considered when ...


\subsection{Satisfaction of Assertions - Time}
 Finally, we  consider assertions involving time. To do this, we need  an  auxiliary concept:
$\adapt$, the adaptation of a runtime configuration to the scope  
of another one. This operator is needed to   the changes of scope during execution. For example, the assertion
$\Future {\x.\f=\prg{3}}$  is satisfied in the \emph{current} configuration % $\sigma$,
 if in some {\em future} configuration the field  \f\, of the object that is pointed at 
 by \x\, in the {\em current} configuration has the value \prg{3}.
 % That is, $\Future {\x.\f=\prg{3}}$  is satisfied in $\sigma$, if there exists a $\sigma'$ in the future of $\sigma$ such that
% $\sigma'[\prg{z}\mapsto\interp \sigma
 Note that in the future  configuration, \x\, may be pointing to a different object, or may
even no longer be in scope (\eg if a nested call  is executed).
Therefore, we introduce the operator \  $\adapt\;$,  \ \ which combines runtime configurations: $\sigma \adapt \sigma'$ adapts the second configuration to the top frame's view of the former: it returns a new configuration whose stack has  the top frame as taken from $\sigma$ and where the \prg{contn} has been consistently renamed, while the heap is taken from $\sigma'$. This allows us to interpret expressions  in the newer (or older) configuration $\sigma'$ but with the variables bound according to the top frame from $\sigma$; \eg we can obtain that value of \prg{x} in configuration  $\sigma'$ even if \prg{x} was out of scope. The consistent renaming of the code allows the correct modelling of execution (as needed,   for the semantics of  nested time assertions, as \eg in $\Future {\x.\f=\prg{3} \wedge \Future {\x.\f=\prg{5}}}$



 \begin{definition}[Adaptation  of Runtime Configurations]   \label{def:config:adapt}
 For runtime configurations $\sigma$, $\sigma'$.$:$
 $~ $ 

\begin{itemize}
\item
$\sigma \adapt \sigma' \triangleq (\phi''\cdot\psi',\chi')$  \IFF $\sigma=(\phi\cdot\_,\_)$, and $\sigma'= (\phi'\cdot\psi',\chi')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $
$\phi$=$(\prg{contn},\varMap)$, and $\phi'$=$(\prg{contn}',\varMap')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $     % $\phi''$ such that
  $\phi''=(\, \prg{contn}'[\prg{zs}/\prg{zs}' ],\,\varMap[\prg{zs}'\mapsto \varMap'(\prg{zs})]\, ) $, where
 \\
$\ \strut \ \ \hspace{1.45in} $
\prg{zs}=$dom(\varMap)$, and
 \\
$\ \strut \ \ \hspace{1.45in} $      $\prg{zs}'$ is a set  of variables with  the  same cardinality as \prg{zs}, and
 \\
$\ \strut \ \ \hspace{1.45in} $   all variables in
$\prg{zs}'$  are fresh in $\varMap$ and in $\varMap'$.
\end{itemize}
\end{definition}

That is, in the new frame $\phi''$ from above, we keep the same continuation as from $\sigma'$ but rename all
variables with fresh names $prg{zs}'$, and in the variable map we comnine that from $\sigma$ and $\sigma'$
but avoid names clashes through the renaming $[\prg{zs}'\mapsto \varMap'(\prg{zs})]$.
With this auxiliary definition, we can now define satisfaction of assertions with involve time:


\begin{definition}[Assertions over Time]  \label{def:valid:assertion:time}
For any modules $\M$, $\M'$, assertions $\A$, $\A'$, variables \prg{x} and \prg{S}, we define
  
\begin{itemize}
 \item
 $\M\mkpair \M', \sigma \models   \Changes{\prg{e}}$  \IFF
 $\exists \sigma'.\, [\ \ \M\mkpair \M',\sigma \leadsto \sigma' \ \wedge \interp{e}{\sigma} \neq \interp{e}{\sigma\triangleleft \sigma'} \ \  ]$.
 \item
  $\M\mkpair \M', \sigma \models  \Next \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto  \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is
so that $\sigma$=$(\phi\cdot\_,\_)$.\item
  $\M\mkpair \M', \sigma \models  \Future \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto^* \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is
so that $\sigma$=$(\phi\cdot\_,\_)$.  
  \item
 $\M\mkpair \M', \sigma \models  \Prev \A $ \IFF
 $\forall \sigma_1, \sigma_2. [\ \ \Initial{\sigma_1}\ \wedge \   \M\mkpair \M', \sigma  \leadsto^*  \sigma_2 \ \wedge \   \M\mkpair \M', \sigma_2  \leadsto   \sigma  
$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \   
 \M\mkpair \M', \sigma\adapt\sigma_2  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
 \item
 $\M\mkpair \M', \sigma \models  \Past \A $ \IFF
 $\forall \sigma_1, ... \sigma_n. [\ \ \Initial{\sigma_1}\ \wedge \  \sigma_n=\sigma 
  \ \wedge \ \forall i\in[1..n). \M\mkpair \M', \sigma_{i} \leadsto  \sigma_{i+1}
$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \  \exists j\in [1..n-1).
 \M\mkpair \M', \sigma\adapt\sigma_j  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
\end{itemize}
\end{definition}

Thus,  $\M\mkpair \M', \sigma \models  \Future \A $ holds if
$\A$ holds in some configuration $\sigma'$ which arises from execution of $\phi$, where $\phi$ is the top frame of $\sigma$. By requiring that $\phi \leadsto^* \sigma' $ rather than
$\sigma \leadsto^* \sigma' $ we are restricting the set of possible future configurations to
just those that are caused by the top frame.
Namely, we do not want to also consider the effect of  enclosing function calls.
This allows us to write more natural specifications
when giving necessary conditions for some future effect.
 

\subsection{Entailment and Equivalence}
 
We define equivalence of   assertions in the usual sense: two assertions are equivalent if they are satisfied  in
the context of the same configurations.
Similarly, an assertion entails another assertion, iff all configurations 
which satisfy the former also satisfy the latter.  

\begin{definition}[Equivalence and entailments of assertions]
$ ~ $

\begin{itemize}
\item
$\A \equiv \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ if and only if }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\item
$\A \subseteqq \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ implies }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\end{itemize}
\end{definition}



\begin{lemma}[Assertions are classical-1]
For all runtime configurations $\sigma$,    assertions $\A$ and $\A'$, and modules $\M$  and $\M'$, we have
\begin{enumerate}
\item
$\M\mkpair \M', \sigma \models \A$\ or\ $\M\mkpair \M', \sigma \models \neg\A$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma \models \A$ and $\M\mkpair \M', \sigma  \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \vee \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma  \models \A$ or  $\sigma \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \neg\A$ never holds.
\item
$\M\mkpair \M', \sigma  \models \A$ and  $\M\mkpair \M', \sigma  \models \A \rightarrow \A'$  implies
$\M\mkpair \M', \sigma  \models \A '$.
\end{enumerate}
\end{lemma}
\begin{proof} By application of the corresponding definitions from \ref{def:valid:assertion}.\end{proof}.

\begin{lemma}[Assertions are classical-2]
For     assertions $\A$, $\A'$, and $\A''$ the following equivalences hold
\label{lemma:basic_assertions_classical}
\begin{enumerate}
\item
$ \A \wedge\neg \A \ \equiv \  \prg{false}$
\item
$ \A \vee \neg\A   \ \equiv \  \prg{true}$
\item
$ \A \wedge \A'  \ \equiv \  \A' \wedge \A$
\item
$ \A \vee \A'  \ \equiv \  \A' \vee \A$
\item
$(\A \vee \A') \vee \A'' \ \equiv \  \A \vee (\A' \vee\A'')$
\item
$(\A \vee \A') \wedge \A'' \ \equiv \  (\A \wedge \A')\, \vee\, (\A \wedge \A'')$
\item
$(\A \wedge \A') \vee \A'' \ \equiv \  (\A \vee \A')\, \wedge\, (\A \vee \A'')$
\item
$\neg (\A \wedge \A') \  \ \equiv \  \neg  \A   \vee\, \neg \A''$
\item
$\neg (\A \vee \A') \  \ \equiv \  \neg  \A   \wedge\, \neg \A''$
\item
$\neg (\exists \prg{x}.\A )  \  \ \equiv \  \forall \prg{x}.(\neg  \A)$
\item
$\neg (\exists k:\mathbb{N}.\A )  \  \ \equiv \  \forall  k:\mathbb{N}.(\neg  \A)$
\item
$\neg (\exists \prg{fs}:FLD^k.\A )  \  \ \equiv \  \forall \prg{fs}:FLD^k.(\neg  \A)$
\item
$\neg (\forall \prg{x}. \A)  \  \ \equiv \  \  \exists \prg{x}.\neg(\A )$
\item
$\neg (\forall k:\mathbb{N}. \A)  \  \ \equiv \  \  \exists k:\mathbb{N}.\neg(\A )$
\item
$\neg (\forall \prg{fs}:FLD^k. \A)  \  \ \equiv \  \  \exists \prg{fs}:FLD^k.\neg(\A )$
\end{enumerate}
\end{lemma}
\begin{proof}
All points follow by application of the corresponding definitions from \ref{def:valid:assertion}.
 \end{proof}

Notice that satisfaction is not preserved with growing configurations; for example, the assertion $\forall \x. [\ \x : \prg{Purse} \rightarrow \x.\prg{balance}>100\ ]$ may hold in a smaller configuration, but not hold in an extended configuration. Nor is it preserved with configurations getting smaller; consider \eg $\exists \x. [\ \x : \prg{Purse} \wedge \x.\prg{balance}>100\ ]$.

% \begin{definition}
%We say that $\sigma \vdash \A$ if for any  \x\, is free in $\A$ and any
%  any term $\x.\f_1...\f_n$ appearing in $\A$,
% the interpretation $\interp{\x.\f_1...\f_n} \sigma$ is defined.
%\end{definition}
%
%Note that if we take $n=0$ in the definition above we obtain as corollary that   all variables that appear free in $\A$ they  are in the domain of the top frame in $\sigma$.
%
%\begin{lemma}[Preservation of satisfaction] $ $
%\label{lemma:preserve:valid}
%\begin{itemize}
%\item
%If  $\sigma \vdash \A$ and $\M\mkpair \M',  \sigma \vdash \A$ and   $\sigma' \subconf \sigma$, \  then  \ $\M\mkpair \M',  \sigma' \models \A$.
%\end{itemize}
%\end{lemma}

Finally, we define satisfaction of assertions by modules: A module $\M$ satisfies an assertion $\A$ if for all modules $\M'$, in all configurations arising from executions of $\M\mkpair\M'$, the assertion $\A$ holds.

\begin{definition}
\label{def:module_satisfies}
For any module $\M$, and  assertion $\A$, we define:
\begin{itemize}
\item
$\M \models \A$ \IFF  $\forall \M'.\, \forall \sigma\!\in\!\Arising{\M\mkpair\M'}.\   \M\mkpair\M', \sigma \models \A$
\end{itemize}
\end{definition}



