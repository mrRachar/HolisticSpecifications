\paragraph{Necessary conditions vs the complement of the sufficient condtiions?}
One might ask whether the necessary conditions are different from the complement of all the sufficient conditions.
In other words, the possible behaviours of a module is the union of all possible behaviours of 
each individual function, and the necessary conditions is their complement,
We described this in the left hand side of the diagram in Figure \ref{fig:NecessaryAndSuff}: we 
represent the space of all theoretically possible behaviours as points in the rectangle, 
each function is a coloured oval and its possible behaviours are the points in the area of that oval.   
Then, the necessary conditions are all the points  outside the ovals.  

This view is mathematically sound but it is  impractical,  brittle wrt software maintenance, and weak wrt reasoning in the open world.

%\footnote{Shall we add this, or is it too technical? 
%It is hypothetical, because it holds only under the hypothesis that all functions have been
%specified with \prg{TRUE} as their preconditions. Namely,  a function is at liberty to behave in any way it
%likes when its precondition does not hold; therefore a function with a precondition different than \prg{TRUE}
%could have a behaviour out
%mean: a function is obligated to deliver its postcondtion if its precondtion holds, but is under no obligation whatsoever when the
%precondtion does not hold. Thus, its beahviour would fall outside the ovals.  }


It is impractical, because it suggests that when interested in a necessity guarantee 
one would need to read the specifications of all the functions  in a module.
In view of the number of these functions, and also 
  the number of   behaviours emerging from their combination, this can be a  very large undertaking.
 What if the bank did indeed enforce that only the account
owner may withdraw funds, but had another function which allowed the manager
to appoint an account supervisor, and another which allowed the account supervisor to
assign owners?

It is brittle wrt software maintenance, because it
 gives no guidance to the team maintaining a piece of software: if the 
necessary conditions which were implicitly in the developers' intentions are not explicitly 
described, subsequent developers may inadvertenty add functions which break these intentions.

It is weak wrt reasoning in the open world because if does not give any guarantees about objects' when
these are passed as arguments to calls into unknown code. For example, what  guarantees  
can we make about the top of the DOM tree when we pass  to an unknown advertiser a wrapper 
pointing to lower parts of the tree.

\paragraph{Design choices}
