 \documentclass[acmsmall,screen,anonymous,review]{acmart}
% \settopmatter{printfolios=true,printccs=false,printacmref=false}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
%\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\setcopyright{none}

% \bibliographystyle{ACM-Reference-Format}
% \citestyle{acmauthoryear}   %% For author/year citations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%  \citestyle{acmauthoryear}
\usepackage{ amssymb }
\usepackage{stmaryrd}


\usepackage{subcaption}
\usepackage{ragged2e}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}
\usepackage{xspace, listings, lstcustom, wrapfig, graphicx, enumerate}
\usepackage{paralist}
\usepackage{color,colortbl, relsize}
\usepackage{rotating}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{soul}
\usepackage{tcolorbox} 
\usepackage[scaled=.9, light]{zlmtt}
\usepackage{siunitx}

 


% Note: the code for hyperlinked images for orcids must come before \include{macros}, otherwise won't compile

%\makeatletter
%\RequirePackage[bookmarks,unicode,colorlinks=true]{hyperref}%
%   \def\@citecolor{blue}%
%   \def\@urlcolor{blue}%
%   \def\@linkcolor{blue}%
%\def\UrlFont{\rmfamily}
%\def\orcidID#1{\smash{\href{http://orcid.org/#1}{\protect\raisebox{-1.25pt}{\protect\includegraphics{orcid_color.eps}}}}}
%\makeatother


\include{macros}

\usepackage{times}
\usepackage{latexsym}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=Java,                % the language of the code
  mathescape=true,
  basicstyle=\footnotesize\tt,           % the size of the fonts that are used for the code
%  numbers=left,                   % where to put the line-numbers
%  numberstyle=\tiny\color{dkgreen},  % the style that is used for the line-numbers
%  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
                                  % will be numbered
%  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
%  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{gray},       % comment style
  stringstyle=\color{mauve},         % string literal style
 % escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={PRE,POST,result,assume,method,mthd,function,fresh,assert,private,then,elseif,public,final,this,throw,new,||,to,def,any,fun,fld,abstract,policy,specification,ghost,field,func}        }  
         % if you want to add more keywords to the set

\newcommand{\kjx}[1]{{\color{orange}{KJX: #1}}}
\newcommand{\scd}[1]{{\color{dkgreen}{SD: #1}}}
\newcommand{\sdN}[1]{{\color{dkgreen}{#1}}}
\newcommand{\jm}[1]{{\color{magenta}{JM: #1}}}
\newcommand{\sdcomment}[1]{{\ensuremath{\blacksquare}}\footnote{\color{dkgreen}{SD: #1}}}
\newcommand{\secomment}[1]{{\ensuremath{\blacksquare}}\footnote{\se{#1}}}
\newcommand{\jncomment}[1]{{\ensuremath{\blacksquare}}\footnote{\kjx{#1}}}

 \newcommand{\sd}[1]{#1} % {{\color{dkgreen}{#1}}}% {#1} %
\newcommand{\tobyM}[1]{#1} %[1]{{\color{purple}{Toby: #1}}}
\newcommand{\se}[1]{#1} %{{\color{blue}{#1}}}


\newcommand{\ponders}[3]{\marginpar{\tiny\itshape\raggedright\textcolor{#2}{\textbf{#1:} #3}}\ignorespaces}
\marginparwidth=1.6cm \marginparsep=0cm
\newcommand{\TODO}[1]{{\color{red}#1}}
\newcommand{\sophia}[1]{#1} % {{\color{red}#1}}
\newcommand{\susan}[1]{#1} % [1]{{\color{blue}#1}} 
\newcommand{\toby}[1]{} % {\ponders{Toby}{purple}{#1}}
%\newcommand{\susan}[1]{} %{\ponders{Susan}{blue}{#1}}
\newcommand{\james}[1]{} % {\ponders{James}{orange}{#1}}

\begin{document}

\title{Towards a Logic for Holistic Reasoning}
 
\author{Clever Guys}

 
\maketitle

 

\section{Abstract}
We want to be able to reason about Holistic Assertions using a logic, rather than through the identification of particular 
configurations. 
In this paper we investigate how this could be done. We fist state some generic lemmas, which are independent of any particular code.
Then we express some code-specific lemmas for class \prg{Safe}. Using these, we outline the proof of 
the specification, which says that the treasure of the safe can change only if an external object has access or its password.
We also point to open problems in the proof.

\section{Generic Properties of Execution}

Below we describe several "general" properties of execution. These will be proven later. %, some by induction over executions.
We start by clarifying the two meanings of implication. 

\begin{definition}
For assertions $A$ and $B$: %, modules $\M$ and $\M'$, state $\sigma$ we define three forms of implication
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models A \longrightarrow B$\  \ \ \ \ if \ \  \ \ \ $\M\mkpair \M', \sigma \models A $ 
implies that $\M\mkpair \M', \sigma \models  B$.
\item
$A \impliesS B$\  \ \ \ \ if \ \  \ \ \ for all $ \M,\M',\sigma$:\  \ $\M\mkpair \M', \sigma \models A $ 
implies that $\M\mkpair \M', \sigma \models  B$
\item
$A \impliesM B$\  \ \ \ \ if \ \  \ \ \  for all $ \M$: \ $\M \models A $ 
implies that $\M  \models  B$
\end{itemize}


\end{definition}


The properties in the lemma below are only concerned with time, while the remaing lemmas are concerned 

\begin{lemma}[Time]
\label{lemma:time}
For any assertions $A$ and $B$:

\begin{enumerate}
\item
$\Future {\Future A}  \ \  \impliesS  \ \  \Future A$
\item 
$A \ \rightarrow B \  \    \impliesM  \ \    \Future A \rightarrow \Future B$
\end{enumerate}

\end{lemma}
Note that $A \ \rightarrow B \ \impliesS   \Future A \rightarrow \Future B$ does \emph{not} hold.


The next properties are concerned with permission, authority and control:

\begin{lemma}[Changes caused by Calls]
\label{lemma:change}
If \prg{f} is a private field of some class \prg{C}, then

\begin{itemize}
\item
$\prg{x}:\prg{C}\ \wedge \   {\Changes{\prg{x.f}}} \ \ \ \impliesS $\\
$\strut\hspace{1in} 
     \exists \prg{o}.\exists \prg{m} .\exists \prg{args}.
[\, {\Calls {\prg{o}}   {\prg{m}} {\prg{x}}  {\prg{args}} }\, ]\ \ $. 

\item
$\prg{x}:\prg{C}\ \wedge \ \Future  {\Changes{\prg{x.f}}} \ \ \impliesS $\\
$\strut\hspace{1in} 
\Future {\ \  \Changes{\prg{x.f}} \ \wedge \exists \prg{o}.\exists \prg{m} .\exists \prg{args}.
[\, {\Calls {\prg{o}}   {\prg{m}} {\prg{x}}  {\prg{args}} }\, ]\ \ }$. 
\end{itemize}
where \prg{m} is a method defined in class \prg{C}.

\end{lemma}
%\begin{proof} Part 2 follows from Part 1 and lemma \ref{lemma:zero}.  \end{proof}

Note that the conclusion of the second bullet of this lemma guarantees that \prg{x.f} changes in some future configuration at which point 
the call \prg{x.m(args)} was going to be executed next.  That means that the change was caused by the method call.

\begin{lemma}[External is Immutable]
\label{lemma:external}
~ ~ 

\begin{enumerate}
\item
$x:\prg{Object} \wedge \External {x} \ \impliesS \ \Next{\External{x}}$
\item
$x:\prg{Object} \wedge \Future{\External {x}} \ \impliesS \ {\External{x}}$
\end{enumerate}
\end{lemma}

Lemma \ref{lemma:external} says that any object that is currently external will be external, and any object wjich is defined now, and will be external at some future point is
also external now. Similar lemma holds for internal. These properties are due to the fact that the class of an object is immutable, and that we
do not have garbage collection.


\begin{lemma}[Calls implies access]
\label{lemma:calls}
~ ~ 

\begin{itemize}
\item
$\Calls {o} {\prg{m}}  {o_r}  {..,o_{arg}...} \ \ \impliesS  \ \ {\CanAccess {o} {o_r}} \ \wedge \  {\CanAccess {o} {o_{arg}} }  $
\end{itemize}
\end{lemma}

Lemma \ref{lemma:calls} says that if $o$ makes a method call, then $o$ must have access to the receiver and the arguments of that call.

\begin{lemma}[Access caused by giving]
\label{lemma:access}
~ ~ 

\begin{itemize}
\item
$o:\prg{Object}\ \wedge\ {\Future {  \CanAccess {o_1} {o} }} \ \ \impliesS  $\\
$\strut \hspace{1in} \CanAccess {o_1} {o}\ \ 
\vee \ \ \exists o_3,o_4.[\ o_3:\prg{Object} \ \wedge\ \ {\Gives {o_3} {o}{o_4}} \ ]  $
\end{itemize}
\end{lemma}

Lemma \ref{lemma:access} says that if $o$ is an object that exists in the current configuration,
 and some time in the future, some $o_1$ has access to $o$,
then either $o_1$ already has access to $o$ in the current configuration, or   
 some time in the future, some object $o_3$ will be giving $o$ to another object $o_4$.
Note that $o_4$ need not be the same as $o_1$.
\footnote{NOTE: We need to revisit the definitions, and ensure that ${\Future {  \CanAccess {o_1} {o} }}$ does not imply that
$o_1:\prg{Object}$, or even more generally,    ${\Future {  o:\prg{Object}}} \ \ \notimpliesS\ \ o:\prg{Object}$. This is a technical matter,
and easily done.}


\subsection{But ... }
Here we list some properties which do not hold:
\begin{enumerate}
\item $\Future{A} \wedge \Future{B}\  \ \notimpliesS\ \Future{A\wedge B}$
\item  $(A \ \rightarrow B) \ \ \notimpliesS \ \   (\Future A \rightarrow \Future B)$
\end{enumerate}

\begin{figure}[htb]
 \begin{tabular}{lll} % {lll}
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
$\M_{s1}$:

class Safe{
   field treasure 
   field secret 
   method take(scr){
      if (secret==scr) then {
         t=treasure
         treasure = null
         return t }  }
 }
\end{lstlisting}
\end{minipage}
  &\ \ \  \ \ \ \ \  \ \ \ \ \ \ &
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}
$\M_{s2}$:

class Safe{
   field treasure   
   field secret  
   method take(scr){
       $\mathit{... as\, version\,1 ...}$ 
   }
   method set(scr){
         secret=scr }
 }
\end{lstlisting}
\end{minipage} 
 \end{tabular}
  \vspace*{-0.95cm}
  \caption{Two Versions of the class \prg{Safe}}
 \label{fig:ExampleSafe}
 \vspace*{-0.65cm}
 \end{figure}


\section{The Safe and its proof}

In figure \ref{fig:ExampleSafe}, we show  a class  \prg{Safe}, implemented in two 
versions, in modules $\M_{s1}$  and  $\M_{s1}$. 
Module  $\M_{s1}$   satisfies (HolSpec), and  module $\M_{s2}$ does not. (HolSpec)
guarantees that the treasure cannot be extracted from the safe
unless  an external object has access to the safe's secret.

\vspace{.1in}
(HolSpec)\ \  $\triangleq$\\ 
$\strut \hspace{.3in}   \forall \prg{s}. % $\\ 
[\ \ \prg{s}:\prg{Safe} \wedge \Future{ \Changes{\prg{s.treasure}}}  $ \\ 
 $ \strut \hspace{4.3cm}     \longrightarrow \ \  \exists \prg{o}. [\  \External{\prg{o}} \wedge  \CanAccess{\prg{o}}{\prg{s.secret}}\ ]  \  \ ]  $
\vspace{.1in}


\vspace{.2in}

We now list some properties of \prg{Safe}.

\begin{lemma}[No effect without secret]
\label{lemma:noeffect}
~ ~ ~

\begin{itemize}
\item $\M_{s1} \models \forall o. \forall \prg{s}.\forall \prg{p}.\, [ \ \prg{s:Safe}\ \wedge\ {\Calls {o} {\prg{take}} {\prg{s}} {\prg{p}} }\ \wedge\
 \prg{s.secret}\neq\prg{p}$\\
 $\strut ~\hspace{2.5in}
\ \longrightarrow \ \neg (\Changes {\prg{s.treasure}} )\ ]$
\end{itemize}

\end{lemma}
\begin{proof} We can prove this using classical reasoning on the method body for \prg{take}.
\end{proof}

\begin{lemma}[Secret is immutable]
~ ~

\label{lemma:secret}
\begin{itemize}
\item $\M_{s1} \models \forall \prg{s}. \forall \prg{p}.\, [ \ \prg{s:Safe} \wedge \Future{\prg{s.secret}=\prg{p} }\ \longrightarrow \ \prg{s.secret}=\prg{p}\ ]$
\end{itemize}

\end{lemma}
This is a longwinded way to say the secret is immutable.

\begin{proof} We can prove using classical reasoning that all methods of the class \prg{Safe} in module  $\M_{s1}$ leave \prg{s.secret} unmodified. Therefore,
as as \prg{secret} is private, we obtain that \\
$\strut \hspace{.4in} \M_{s1} \models \forall \prg{s}. \forall \prg{p}.\, [ \ \prg{s:Safe} \wedge \prg{s.secret}=\prg{p} \ \longrightarrow \Next{\prg{s.secret}=\prg{p} } \ ] $.\\
I think that there should be some "generic" reasoning steps which allow us to transform the above to the format in the lemma.
\end{proof}





\section{Proof that \prg{Safe} satisfies  (HolSpec)}


\begin{theorem}
%\begin{itemize} \item
 $M_{s1} \models (HolSpec) $
%\end{itemize}
\end{theorem}
\begin{proof}
We write the proof steps. We avoid talking about individual configurations. 
% We assume that $\prg{s}:\prg{Safe} \wedge \Future{ \Changes{\prg{s.treasure}}}  $.\\

%Then,

 
\begin{tabular}{ll}
(1) & $ \prg{s}:\prg{Safe} \wedge \Future{ \Changes{\prg{s.treasure}}}  $ \\
&  \hspace{1.5in}  (Assume) 
\\
(2) & $  \prg{s}:\prg{Safe} \wedge  \Future{ \Changes{\prg{s.treasure}} \ \wedge \exists \prg{o}.\exists \prg{m} .\exists \prg{args}.
[\, {\Calls {\prg{o}}   {\prg{m}} {\prg{s}}  {\prg{args}} }\, ]\ \ }$\\
&     \hspace{1.5in}  where \prg{m} a method in the class of \prg{s} \\
& \hspace{1.5in}  by (1) and Lemma \ref{lemma:change}
\\
(3) & $  \prg{s}:\prg{Safe} \wedge  \Future{ \Changes{\prg{s.treasure}} \ \wedge \exists \prg{o}.\exists \prg{p}.
[\, {\Calls {\prg{o}}   {\prg{take}} {\prg{s}}  {\prg{p}} }\, ]\ \ }$\\
&   \hspace{1.5in}  by code of $\M_{s1}$
\end{tabular}

\textbf{1st Case}: $\prg{p}\neq\prg{s.secret}$

We proceed to show that no change can happen

\begin{tabular}{ll}
(4) & $ \neg(\Changes{\prg{s.treasure} })  $ \\
& \hspace{1.5in} by Lemma \ref{lemma:noeffect}  
\\
&   \hspace{1.5in} CAREFUL: In the above we need to be able to  talk about the \\
&  \hspace{1.5in}  specific future configuration that (3) is talking about.\\
&  \hspace{1.5in} this step is imprecise
\\
(5) &   contradiction of (4) and (3)
\end{tabular}

\textbf{2nd Case}: $\prg{p}=\prg{s.secret}$

We proceed to show that \prg{o}, the caller, will have access to the password:

\begin{tabular}{ll}
(4) & $ \prg{s}:\prg{Safe} \wedge  \Future{   \exists \prg{o}.[\  {\Calls {\prg{o}}   {\prg{take}} {\prg{s}} {\prg{s.secret}} }\ \wedge\ {\CanAccess {o} {\prg{s.secret}}\ ]\ \ } }$ \\
&\hspace{1.5in}(by (3), Lemma \ref{lemma:calls}, and case (ie $\prg{p}=\prg{s.secret}$).
\\
(5) &   $ \prg{s}:\prg{Safe} \wedge  \Future{   \exists \prg{o}.[\ \External{o} \ \wedge \ {\CanAccess {o} {\prg{s.secret}}\ ]\ \ } }$ \\
 & \hspace{1.5in} (by (4), and code of $\M_{s1}$ -- as nothing in \prg{Safe} in of $\M_{s1}$ makes a call
\end{tabular}

Take \prg{o1}, so that\\
\begin{tabular}{ll}
(6) & $\Future{     \External{o1} \ \wedge \ {\CanAccess {o1} {\prg{s.secret}}} }  $ \\
& \hspace{1.5in} from (5), such an  \prg{o1} exists\\
(6) & $\exists \prg{p}. [ \ \prg{s.secret } = \prg{p}\ \wedge \ \Future{     \External{o1} \ \wedge \ {\CanAccess {o1} {\prg{p}}} }  \ ]$\\
& \hspace{1.5in} by Lemma \ref{lemma:secret}, and some more thinking needed, but this should be OK

\end{tabular}

\noindent
\textbf{2.1 Case}: $ \exists \prg{o}.[\ \External{o} \ \wedge \ {\CanAccess {o} {\prg{s.secret}}} \ ]$
\\
Then we are done.
\\

\noindent
\textbf{2.2 Case}: $ \forall \prg{o}.[\ \External{o} \ \rightarrow \ \neg({\CanAccess {o} {\prg{s.secret}}} )\ ]$.
\\
Then, we will use lemma \ref{lemma:access}, and the fact that only externals can give in $\M_{s1}$ and then we wil have a contradiction.



\end{proof}

\section{And here the proof with configurations explicit}

This is the more straightforward version of the same proof.
Take an arbitrary module $\M$, and an arbitrary  $\sigma$ arising from ...
\begin{proof}
 
\begin{tabular}{ll}
(1) & $ \M\mkpair \M_{s1} \sigma \models \prg{s}:\prg{Safe} \wedge \Future{ \Changes{\prg{s.treasure}}}  $ \\
&  \hspace{1.5in}  (Assume) 
\\
(2) & $  \\M\mkpair\M_{s1} , \sigma \models prg{s}:\prg{Safe} \wedge  \Future{ \Changes{\prg{s.treasure}} \ \wedge \exists \prg{o}.\exists \prg{m} .\exists \prg{args}.
[\, {\Calls {\prg{o}}   {\prg{m}} {\prg{s}}  {\prg{args}} }\, ]\ \ }$\\
&     \hspace{1.5in}  where \prg{m} a method in the class of \prg{s} \\
& \hspace{1.5in}  by (1) and Lemma \ref{lemma:change}
\\
(3) & $  \M\mkpair \M_{s1} , \sigma \models \prg{s}:\prg{Safe} \wedge  \Future{ \Changes{\prg{s.treasure}} \ \wedge \exists \prg{o}.\exists \prg{p}.
[\, {\Calls {\prg{o}}   {\prg{take}} {\prg{s}}  {\prg{p}} }\, ]\ \ }$\\
&   \hspace{1.5in}  by code of $\M_{s1}$
\\
(4) & \exists \sigma'[\ \M\mkpair \M_{s1}, \sigma \leadsto^* \sigma' \ \wedge  M\mkpair \M_{s1}, \sigma' \models 
\end{tabular}

\textbf{1st Case}: $\prg{p}\neq\prg{s.secret}$

We proceed to show that no change can happen

\begin{tabular}{ll}
(4) & $ \neg(\Changes{\prg{s.treasure} })  $ \\
& \hspace{1.5in} by Lemma \ref{lemma:noeffect}  
\\
&   \hspace{1.5in} CAREFUL: In the above we need to be able to  talk about the \\
&  \hspace{1.5in}  specific future configuration that (3) is talking about.\\
&  \hspace{1.5in} this step is imprecise
\\
(5) &   contradiction of (4) and (3)
\end{tabular}

\textbf{2nd Case}: $\prg{p}=\prg{s.secret}$

We proceed to show that \prg{o}, the caller, will have access to the password:

\begin{tabular}{ll}
(4) & $ \prg{s}:\prg{Safe} \wedge  \Future{   \exists \prg{o}.[\  {\Calls {\prg{o}}   {\prg{take}} {\prg{s}} {\prg{s.secret}} }\ \wedge\ {\CanAccess {o} {\prg{s.secret}}\ ]\ \ } }$ \\
&\hspace{1.5in}(by (3), Lemma \ref{lemma:calls}, and case (ie $\prg{p}=\prg{s.secret}$).
\\
(5) &   $ \prg{s}:\prg{Safe} \wedge  \Future{   \exists \prg{o}.[\ \External{o} \ \wedge \ {\CanAccess {o} {\prg{s.secret}}\ ]\ \ } }$ \\
 & \hspace{1.5in} (by (4), and code of $\M_{s1}$ -- as nothing in \prg{Safe} in of $\M_{s1}$ makes a call
\end{tabular}

Take \prg{o1}, so that\\
\begin{tabular}{ll}
(6) & $\Future{     \External{o1} \ \wedge \ {\CanAccess {o1} {\prg{s.secret}}} }  $ \\
& \hspace{1.5in} from (5), such an  \prg{o1} exists\\
(6) & $\exists \prg{p}. [ \ \prg{s.secret } = \prg{p}\ \wedge \ \Future{     \External{o1} \ \wedge \ {\CanAccess {o1} {\prg{p}}} }  \ ]$\\
& \hspace{1.5in} by Lemma \ref{lemma:secret}, and some more thinking needed, but this should be OK

\end{tabular}

\noindent
\textbf{2.1 Case}: $ \exists \prg{o}.[\ \External{o} \ \wedge \ {\CanAccess {o} {\prg{s.secret}}} \ ]$
\\
Then we are done.
\\

\noindent
\textbf{2.2 Case}: $ \forall \prg{o}.[\ \External{o} \ \rightarrow \ \neg({\CanAccess {o} {\prg{s.secret}}} )\ ]$.
\\
Then, we will use lemma \ref{lemma:access}, and the fact that only externals can give in $\M_{s1}$ and then we wil have a contradiction.



 

 
\end{document} 

