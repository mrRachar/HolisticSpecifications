 \section*{LATEX mysteries and terminology}
 
 1) How can we make the references refer to the Definitions, Lemmas etc rather than the section where these appear?
 
 2) Improve the "looks" of $\SE$ and of $\SA$, perhaps call them \prg{pth} and $\B$ instead?
 
 3) Need a nice metavariable for set of addresses, currently it is $R$. Perhaps instead use an enumeration, as eg $\{ \ \iota_1,...\iota_n\ \} $
 or $\kappa$?
 
4) Find a nice term  to refer to module pairs  (internal, external), and a term for 
our version visible states semantics.

5) Better symbols for module linking (currently a $\M\link\M'$), and 
for module pairing (currently a $\M\mkpair \M'$) -- perhaps there should not be such an operator, as
it does not create a new module, it is only used in execution ($\M\mkpair \M', \sigma \leadsto \sigma'$) and in validity of assertions ($\M\mkpair \M', \sigma\models \A$).


\section{ \LangOO\ and Modules}

Modules are repositories for class lookups, and have a special entry, under \prg{Internal} to describe the internals of 

\begin{definition}[Modules]
We define $\syntax{Module}$-s  as  the set of mappings from identifiers to class descriptions or a simple assertion\\  % to force line break

\begin{tabular}  {@{}l@{\,}c@{\,}ll}
\syntax{Module} \ \  &    =   &  
   $ \{ \ \ \M \ \ \mid \ \  \M: \ \prg{Identifier} \   \longrightarrow \
  \ ( \  \syntax{ClassDescr}     \cup  \syntax{SimpleAssertion} \ ) \ \ \} $ \\
 & & $\strut \ \ \ \ \quad\quad$ such that
 $\M(\prg{Internal})\in \syntax{SimpleAssertion}$, \\
& & $\strut \ \ \ \ \quad\quad$  and \  $\forall \prg{C}\in dom(\M). \ [ \ \prg{C}\neq\prg{Internal}\ \rightarrow\ \M(\prg{C})\in \syntax{ClassDescr}\ ] $   \  $ \ \}$
 \end{tabular}
\end{definition}

We describe \syntax{ClassDescr}-s in Definition \ref{def:syntax:classes}, and  \syntax{SimpleAssertion}-s in Definition 
 \ref{def:syntax:classes}.



\paragraph{Classes}

Class definitions are described below. 
Note that the language is untyped. Method bodies consist of sequences of statements; 
these can be field read or field assignments (only allowed if the target object is \prg{this} -- i.e. as in Smalltalk), and method calls. 
All else can be encoded.
TODO: explain why we want   $Arg$ (SD has forgotten the reason)
 
 \begin{definition}[Classes, Methods, Arguments]
\label{def:syntax:classes}
We define the syntax of modules below.

\begin{tabular}{lcll}
 \syntax{ClassDescr}   &   \BBC  &     \kw{class}  \syntax{ClassId}    \lb\,  $($\ \kw{field} \syntax{FieldId}\ $)^*$ \    
 $($\ \syntax{methBody}\ $)^*$   \ \rb
\\
\syntax{methBody} &\BBC&
     \kw{method}    m\lp \syntax{ParId}  \rp   \lb\, \syntax{Stmts} \semi   \kw{return}  \syntax{Arg}  \,
    \rb
 \\
 \syntax{Stmts}  &\BBC&  \syntax{Stmt}     ~\SOR~  \syntax{Stmt} \semi \syntax{Stmts} \\
\syntax{Stmt}    &\BBC&   
 \syntax{VarId} {\kw{:=}} \syntax{Rhs}
   ~\SOR~      \kw{this}.\syntax{FieldId} {\kw{:=}} \syntax{Rhs} \\
 \syntax{Rhs} & \BBC&    {\syntax{Arg}}{\kw{.}}\syntax{MethId}\lp  \syntax{Arg}  \rp    ~\SOR~   \syntax{Arg}  
  ~\SOR~     {\kw{new} \syntax{ClassId}\lp \, \syntax{Arg}$^*$\, \rp} \\
 \syntax{Arg} &\BBC&  \syntax{ParId} ~\SOR~ \syntax{VarId} ~\SOR~ {\kw{this}} 
 ~\SOR~ {\kw{this}}.\syntax{FieldId}
 \end{tabular}
\end{definition}

Note that \LangOO\, supports a limited form of protection: like in Smalltalk,
  the syntax allows an object to read/write its own fields, but forbids it from reading/writing any other object's fields.
   
We define  method lookup function, $\mathcal{M}$ which returns the corresponding method definition given a class and a method identifier, where we assume that \prg{C} is a class identifier,   \prg{m} a method identifier: $ ~ $ \\

  
 \begin{definition}[Lookup]For a class identifier \prg{C}  and a method identifier \prg{m} : $ ~ $ \\

\noindent
$
\Meths {} {\prg{C}} {m}      =  \ \left\{  
\begin{array}{l}
                          \kw{method}\, m\, \lp p_1, ... p_n \rp \lb stms \semi\, \kw{return}\ {\syntax{a}} \rb\\
\hspace{1in} \mbox{if}  \M(\prg{C}) =   
\kw{class}\, \prg{C}\, \  \lb ...   \kw{method}\, m\, \lp p_1, ... p_n \rp \lb stms \semi\, \kw{return}\ {\syntax{a}} \rb  ... \rb.  
\\
\mbox{undefined},  \ \ \ \mbox{otherwise.}
\end{array}
                    \right.$
 
${\mathcal{ I}} ( {\M} ) \    =  \     \M(\prg{Internal} )$
  \end{definition}

\subsection{The Operational Semantics of \LangOO}
\label{formal:semantics}

TODO define runtime configurations $\sigma$.
Define operational semantics, of the form $\M, \sigma \leadsto \sigma'$ -- what about return values?

\begin{definition}[Lookup in runtime configurations]
We define convenient shorthands for looking up in a runtime configuration $\sigma$. We assume that
$\sigma$ consists of components so that $\sigma$ = $(\phi.\sigma', \chi, \prg{code} )$.
\begin{itemize}
\item 
$\sigma(\prg{x})$ = $\phi(\prg{x})$ 
\item
$\sigma(\iota, \prg{f})$ = $\chi(\iota,\prg{f})$ 
\item
$\ClassOf {\iota} {\sigma} $ = $\chi(\iota)\downarrow_1$
\end{itemize}

\end{definition}

TODO add definition of  $\Initial$ -- probably exists in rest.tex

\subsection{Module linking}

 In this section we define  module linking and module ??? term ???
 
 Linking is an operation that takes two modules, and creates a module which corresponds  to the union of the two. We use the concept of module linking in order to model the open world, where our module $\M$ whose code we know, will be executed together with further modules whose code we do not know. 

We place some conditions for module linking to be defined: We require that the two modules do not contain implementations for the same class identifiers,  

\begin{definition}[Module Linking]

The linking operator $\link: \syntax{Module} \times  \syntax{Module} \longrightarrow \syntax{Module}$ is defined as follows:

$
\M \link \M{'}  =\ \left\{
\begin{array}{l}
                        \M \link_{aux} \M{'},\ \ \   \hbox{if}\  \ dom(\M)\!\cap\!dom(\M')\!=\!\emptyset\\
\bot  \ \ \ \mbox{otherwise.}
\end{array}
                    \right.$
                    
and where,                  
\begin{itemize}
     \item 
   For \prg{C}$\neq\prg{Internal}$, we have: \ \
   $(\M \link_{aux} \M')(\prg{C})$ = $\M(\prg{C})$  if  $\prg{C}\in dom(\M)$, and  $\M'(\prg{C})$ otherwise.
    \item  
   $(\M \link_{aux} \M')(\prg{Internal})$ = $ \M(\prg{Internal}) \cup  \M'(\prg{Internal})$
 \end{itemize}
\end{definition}

 
 \begin{lemma}[properties of linking]
 For any modules $\M$,   $\M'$ and $\M''$, and runtime configurations $\sigma$, we have$:$
 \label{lemma:linking:properties}
 
 \begin{itemize}
     \item 
     $(\M \link \M')\link \M''$ = $\M \link (\M' \link \M'')$.
    \item  
      $\M \link \M'$  = $\M' \link\M$.
      \item
      $\M, \sigma \leadsto \sigma'$  implies that  $\M\link \M', \sigma \leadsto \sigma'$
   \end{itemize}
 
 \end{lemma}
 
\section{ Assertions}

Assertions allow us to reflect over the current runtime configuration, but also over possible future and past configurations, over 
the control ... TODO describe this
A simpler form of assertion only reflects over the current runtime configuration. These are described in Definition \ref{def:simple_assertion}.
 
 \subsection{Simple Assertions}
 \label{def:simple_assertion}
 \begin{definition}[Simple Expressions and simple Assertions] $ $ \\
 
 $\begin{array}{lcl}
 \SE & ::= &  \prg{true}  \ \mid\ \prg{false}  \ \mid \ \prg{x}  \ \mid\ \prg{this}  \ \mid \ \SE.\prg{f} \    \ \mid \ \SE.\prg{f}^n \  \\
 ~ \\
  \SA\ &\ \  ::=\ \  & \SE  \ \mid \ \SE > \SE \ \mid \  \SE=\SE  \ \mid \ \SE \equiv \SE \ \mid  \ \SA \rightarrow \SA \ \mid \   \SE:\prg{ClassId}  \ \mid \   
    \SE\in\prg{S}  \\
 & &   \exists \prg{x}.\SA  \ \mid \  \exists \prg{S}:SET.\SA  \ \mid \  \exists fs:FLD^k.\SA
 \ \mid \  \exists k:\mathbb{N}.\SA  
\end{array}$

\noindent
In the above, \prg{f} is a field identifier , and  $n$ is a natural number.
\end{definition} 

Simple expressions have a value which can be determined with reference to 

\begin{definition}[Interpretations]

For any runtime configuration, $\sigma$, and any simple expression, $\SE$, and any $k\in \mathbb{N}$ we define its interpretation as follows:

\begin{itemize}
     \item 
  $\interp {\prg{true}}{\sigma}$ = \prg{true}, \ and \ \    $\interp {\prg{false}}{\sigma}$ = \prg{false}, \ and \ \ 
   $\interp {\prg{null}}{\sigma}$ = \prg{null}
  \item
  $\interp {\prg{x}}{\sigma}$ = $\sigma(\prg{x})$
  \item
  $\interp {\SE.\prg{f}}{\sigma}$ = $\sigma({\interp {\SE}{\sigma}}, \prg{f})$
  \item
    $\interp {\SE.\prg{f}^0}{\sigma}$ =  $\interp {\SE}{\sigma}$, \ \ \ and \ \ \ $\interp {\SE.\prg{f}^{k+1}}{\sigma}$ =  $\sigma({\interp {\SE.\prg{f}^k}{\sigma}}, \prg{f})$
   \end{itemize}
\end{definition}

\begin{lemma}[Interpretation corresponds to execution]
For any simple expression $\SE$, runtime configuration $\sigma$, and value $v$:

\begin{itemize}
     \item 
  $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M_\emptyset, \sigma[\prg{code}\mapsto \SE] \leadsto v$,\\
  where $\M_\emptyset$ stands for the empty module.
  \item
   $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M, \sigma[\prg{code}\mapsto \SE] \leadsto v$ \ \ \ for any module $\M$ .
   \end{itemize}
   \end{lemma}
   
   \begin{proof} The  first guarantee is proven structural induction  over the definition of $\SE$.
   The second guarantee  is a corollary of the first guarantee  and of lemma \ref{lemma:linking:properties}.\end{proof}


The validity of simple assertions can be judged in the context of a runtime configuration

 \begin{definition}[Validity of Simple Assertions] is defined  as follows

\begin{itemize}
\item
$\sigma \models \SE$ \IFF  $\interp{\SE}{\sigma}$ = \prg{true}.
\item
$\sigma \models \SE>\SEPrime$ \IFF $\interp{\SE}{\sigma}$ > $\interp{\SEPrime}{\sigma}$.
\item
$\sigma \models \SE=\SEPrime$ \IFF $\interp{\SE}{\sigma}$ = $\interp{\SEPrime}{\sigma}$.
\item
$\sigma \models \SE\equiv\SEPrime$ \IFF $\SE$ and $\SEPrime$ are textually identical.
\item
$\sigma \models \SA \rightarrow \SAPrime $ \IFF $\sigma \models \SA$ implies $\sigma \models \SAPrime$. 
\item
$\sigma \models  \SE:\prg{ClassId}$ \IFF $\ClassOf {\interp{\SE}{\sigma}} {\sigma}$ = $\prg{ClassId}$.
\item
$\sigma \models  \SE\in \prg{S}$ \IFF $\interp{\SE}{\sigma}\in \interp{\prg{S}}{\sigma}$
\item
$\sigma \models  \exists x.\SA$ \IFF  exist  $\iota\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\SA$, so that
$\sigma[\prg{z}\mapsto \iota] \models  \SA[\prg{x}/\prg{z}]$ \footnote{TO THINK: if \prg{x} is free in $A$ and $\sigma$ it could be simplified}
\item
$\sigma \models  \exists \prg{S}:\prg{SET}.\SA$ \IFF  exists a set of addresses $R\subseteq dom(\sigma)$, and a \prg{Q} free in $\sigma$ and $\SA$, so that
$\sigma[\prg{Q}\mapsto R \models  \SA[\prg{S}/\prg{Q}]$ 
\item
$\sigma \models  \exists \prg{fs}:\prg{FLD}^k.\SA$ \IFF  exist $k$ field identifiers $\prg{f}_1$, ... $\prg{f}_k$ so that 
$\sigma \models  \SA[\prg{fs}/\prg{f}_1.\,...\,\prg{f}_k]$ 
\item
$\sigma \models  \exists \prg{n}:\prg{Nat}.\SA$ \IFF  exists a $m\in\mathbb{N}$, so that $\sigma \models    \SA[\prg{n}/m]$ 
\footnote{TO THINK Should we instead allow the frames to map variables to numbers as we do for sets?}
\end{itemize}
\end{definition}

Simple assertions form a classical logic: TODO: check the term; also to check whether we need any more from the classical logic's properties, since the rest of them probably hold by definition.

Using this small language of simple assertions we can encode all the classical connectives, \ie $\wedge$, and $\vee$ and $\neg$. We can also model


\begin{lemma}[Simple Assertions are classical]
For all runtime configurations $\sigma$, and simple assertions $\SA$ and $\SAPrime$, we have
\label{lemma:simple_assertions_classical}
\begin{itemize}
\item
$\sigma \models \SA$ or $\sigma \models \neg\SA$
\item
$\sigma \models \SA \wedge \SAPrime$ \SP if and only if \SP $\sigma \models \SA$ and  $\sigma \models \SAPrime$ 
\item
$\sigma \models \SA \vee \SAPrime$ \SP if and only if \SP $\sigma \models \SA$ or  $\sigma \models \SAPrime$ 
\item
$\sigma \models \SA \wedge \neg\SA$ never holds.
\end{itemize}
\end{lemma}
\begin{proof} By induction over the structure of $\SA$ -- TODO think it a but more. No doubt lemma holds, 
but perhaps we need some auxiliary lemmas, as we are using encodings. \end{proof}.


\subsection{Module pairs and visible states semantics}

TODO: make the connection with classical visible state semantics, explain why ours is more flexible. why we use \prg{Internal} instead. Wexplain the internal-external part of the pair $\M\mkpair\M'$.

 
\begin{definition}
Given runtime configurations $\sigma$,  $\sigma'$,  and module $\M$ $\M'$ we define  
\label{def:module_pair_execution} trough execution,
\begin{itemize}
\item
$\M \mkpair \M', \sigma \leadsto \sigma'$ \IFF  
there exists runtime configurations $\sigma_1$,  ...
$\sigma_n$, such that 
\begin{itemize}
\item
$\sigma$=$\sigma_1$,\ \  \ \ and\ \ \ \ $\sigma_n=\sigma'$.
\item
$\M \link \M', \sigma_i \leadsto \sigma_{i+1}'$,\  \  for $1\leq i \leq n\!-\!1$
\item
$\sigma \not\models {\mathcal I}({\M})$, \ \ \ \ and\ \ \ \  $\sigma' \not\models {\mathcal I}({\M})$, \ \ \ \ and\ \ \  \
$\sigma_i \models {\mathcal I}({\M})$,\ \ for $2\leq i \leq n\!-\!2$
\end{itemize}
\end{itemize}

\end{definition}

And we can prove that ...

\begin{lemma}[xxx]
\label{lamma:module_pair_execution} 
For any modules $\M$, $\M'$, and $\M''$, and runtime configurations $\sigma$, $\sigma'$, 

\begin{itemize}
\item
 $\M \mkpair \M', \sigma \leadsto \sigma'$  implies $\M \mkpair (\M'\link\M') ,\sigma \leadsto \sigma'$.
\end{itemize}
\end{lemma} 

But note that in general $\M \mkpair \M', \sigma \leadsto \sigma'$  does not imply
$(\M\link\M'') \mkpair \M' , \sigma \leadsto \sigma'$.


We also define 
\begin{definition}
$\Arising {\M\mkpair\M'} \ = \ \{ \sigma \ \mid \ \exists \sigma_0 \in \Initial. \M\mkpair\M', \sigma \leadsto^* \sigma' \} $
\end{definition}
 
 \subsection{Assertions}

TODO explain at a high level what "full assertions" .are. Also, introduce the need  for spatial restriction. 

We will define the OCAP assertions $\CanAccess{\_}{\_}$  (permission)
and   $\Changes{\_}$ (authority). \footnote{Note that they are slightly different
assertions to those we had in the past.}
We also add temporal modifiers, where $\Future \A$ expresses that $\A$ will hold at some future point,
$\Past \A$ expresses that $\A$ held at some point in the past.
We also add a {\em spatial modifier}, $\Using{\A}{S}$, which expresses that assertion $\A$ holds in
the sub-configurations determined by the witness \prg{S}.

We extend the syntax for assertions as follows:\footnote{The symbols are not that good -- esp the symbols for future and past.}

\begin{definition}[Assertions]We define the syntax of assertions ($\A$) as below:
\label{def:assertions}

$\begin{array}{lcl}
\A &\ ::=\  &  \SA \ \mid  \ \A \rightarrow \A \ \mid \     \exists \prg{x}.\A  \ \mid \  \exists \prg{S}:SET.\A  \ \mid \  \exists fs:FLD^k.\A
 \ \mid \  \exists k:\mathbb{N}.\A  \ \mid \ \\
 & &    \CanAccess x y \ \mid\  \ \Changes e \ \mid\  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}} \ \mid\  \  \Future \A  \ \mid \  \Past \A \ \mid \ \Using \A \prg{S }
\end{array}$
\end{definition} 

Validity of assertions has the format $\M\mkpair \M', \sigma \models \A$ - TODO justify why \M, and why we need an external/internal part.

\begin{definition}[Validity of  Assertions] is defined  as follows

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models\SE$ \IFF  $\interp{\SE}{\sigma}$ = \prg{true}.
\item
$\M\mkpair \M', \sigma \models\SE>\SEPrime$ \IFF $\interp{\SE}{\sigma}$ > $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE=\SEPrime$ \IFF $\interp{\SE}{\sigma}$ = $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE\equiv\SEPrime$ \IFF $\SE$ and $\SEPrime$ are textually identical.
\item
$\M\mkpair \M', \sigma \models\A \rightarrow \A' $ \IFF $\M\mkpair \M', \sigma \models\A$ implies $\M\mkpair \M', \sigma \models\A'$. 
\item
$\M\mkpair \M', \sigma \models \SE:\prg{ClassId}$ \IFF $\ClassOf {\interp{\SE}{\sigma}} {\sigma}$ = $\prg{ClassId}$.
\item
$\M\mkpair \M', \sigma \models \SE\in \prg{S}$ \IFF $\interp{\SE}{\sigma}\in \interp{\prg{S}}{\sigma}$
\item
$\M\mkpair \M', \sigma \models \exists x.\A$ \IFF  exist  $\iota\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$, so that
$\sigma[\prg{z}\mapsto \iota] \models  \A[\prg{x}/\prg{z}]$ 
\item
$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}.\A$ \IFF  exists a set of addresses $R\subseteq dom(\sigma)$, and a \prg{Q} free in $\sigma$ and $\A$, so that
$\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ 
\item
$\M\mkpair \M', \sigma \models  \exists \prg{fs}:\prg{FLD}^k.\A$ \IFF  exist $k$ field identifiers $\prg{f}_1$, ... $\prg{f}_k$ so that 
$\M\mkpair \M', \sigma \models  \A[\prg{fs}/\prg{f}_1.\,...\,\prg{f}_k]$ 
\item
$\M\mkpair \M', \sigma \models  \exists \prg{n}:\prg{Nat}.\A$ \IFF  exists a $m\in\mathbb{N}$, so that $\M\mkpair \M', \sigma \A[\prg{n}/m]$ 
\item
$\M\mkpair \M', \sigma \models  \CanAccess{\prg{x}}{\prg{y}}$   \IFF  \begin{itemize}
\item
$\sigma(x)$=$\sigma(y)$, or
\item
$\sigma(\prg{x},\prg{f})$=$\sigma(\prg{y})$  for some field \prg{f},  or
\item
$\sigma(\prg{this})$=$\sigma(\prg{x})$ and
  $\sigma(\prg{z})$=$\sigma(\prg{y})$,
  $\strut \hspace{0.1cm}$
for some some parameter of local variable \prg{z}.
 \end{itemize}
 \item
 $\M\mkpair \M', \sigma \models   \Changes{\prg{e}}$  \IFF 
 $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto \sigma' \ \wedge \interp{e}{\sigma} \neq \interp{e}{\sigma,\sigma'} \ \  ]$,\\
 where $\phi$ is so that $\sigma$=$\phi.\_$.\footnote{explain why we take $\phi$}
 \item
$\M\mkpair \M', \sigma \models  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}}$ \IFF \
 $\sigma.\prg{code}$=\prg{u.m(v);\_} for some variables \prg{u} and \prg{v},  \ and \  
$\interp{\prg{this}}{\sigma}$=$\interp{\prg{x}}{\sigma}$, \ and\ $\interp{\prg{y}}{\sigma}$=$\interp{\prg{u}}{\sigma}$,
 \ and\ $\interp{\prg{z}}{\sigma}$=$\interp{\prg{v}}{\sigma}$.
 \item
  $\M\mkpair \M', \sigma \models  \Future \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto^* \sigma' \ \wedge \M\mkpair \M',\sigma,\sigma' \models \A \ \  ]$,\\
 where $\phi$ is so that $\sigma$=$\phi.\_$.

 \item
 $\M\mkpair \M', \sigma \models  \Past \A $ \IFF 
 $\forall \sigma_1, ... \sigma_n. [\ \ \sigma_1\in \Initial{}\ \wedge \ 
 \forall i\in\{1..n-1\}. \M\mkpair \M', \sigma_{i} \leadsto  \sigma_{i+1} \ \wedge \ 
 \sigma_n=\sigma \ \ \longrightarrow \ \ \exists j\in\{1..n-1\}.
 \M\mkpair \M', \sigma, \sigma_j  \models \A\ \ 
 ]$\footnote{past includes the present, perhaps change this}
 
 \item
 $\M\mkpair \M', \sigma \models \Using \A \prg{S}$
 \IFF
 $\M\mkpair \M', \sigma\mid_R \models  \A  $,\ \ where \ $R$=$\interp{R}{\sigma}$


\end{itemize}
We use the following two auxiliary definitions:
\begin{itemize}
\item
$\interp{e}{\sigma,\sigma'}$ \ =\  $\interp{e[\prg{zs}/\prg{us}]}{\sigma'[\prg{us}\mapsto\sigma(\prg{zs}]}\ \ ]$,\\
 where   \prg{zs} is the set of variables which appear free in \prg{e}, and   \prg{us}  is a set of variables 
 which do not appear in \prg{e} nor in $dom(\sigma)\cup dom(\sigma')$ with same cardinality as \prg{zs}.
 \footnote{We need to argue that the value of $\interp{e}{\sigma,\sigma'}$ is not affected by the choice of
\prg{us}. Easy but boring.}
\item
$\M\mkpair \M',\sigma,\sigma' \models \A $ \IFF $\M\mkpair \M',\sigma'[\prg{us}\mapsto\sigma(\prg{zs}0] \models \A[\prg{zs}/\prg{us}]$,
 where   \prg{zs} is the set of variables which appear free in \A, and   \prg{us}  is a set of variables 
 which do not appear in \prg{e} nor in $dom(\sigma)\cup dom(\sigma')$ with same cardinality as \prg{zs}.
 \footnote{Again, have argue that validity of $\M\mkpair \M',\sigma,\sigma' \models \A $ is not affected by the choice of
\prg{us}. }
\item
$\sigma\mid_R$ where $R$ is a set of addresses, is a new runtime configuration, $\sigma'$, such that\\
$\sigma'.\prg{frames}$=$\sigma.\prg{frames}$, 
and 
$\sigma'.\prg{code}$=$\sigma.\prg{code}$, and
and
$dom(\sigma'.\prg{heap})$=$R$, and  l $\forall \iota\in R.\sigma'.\prg{heap}(\iota)=\sigma.\prg{heap}(\iota)$.
\end{itemize}
\end{definition} 

\noindent
{\bf Question} SD wonders whether we should have taken the ${\mathcal I}(\M)$ aspect in some of
the definitions  earlier on. 
For example, should we have defined
\begin{enumerate}
\item 
$\M\mkpair \M', \sigma \models \exists x.\A$ \IFF  exist  $\iota\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$, \hl{and $\sigma[\prg{z}\mapsto \iota] \not\models {\mathcal I}(\M)[\prg{this}/\prg{z}]$}  so that
$\sigma[\prg{z}\mapsto \iota \models  \A[\prg{x}/\prg{z}]$ 
\item
$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}.\A$ \IFF 
 exists a set of addresses $R\subseteq dom(\sigma)$, and a \prg{Q} free in $\sigma$ and $\A$, so that
\hl{for all $\iota\in R$,} for \prg{z}    free in $\sigma$ and $\A$, \hl{we have }
  \hl{$\sigma[\prg{z}\mapsto \iota] \not\models {\mathcal I}(\M)[\prg{this}/\prg{z}]$}, and
$\M\mkpair \M', \sigma[\prg{Q}\mapsto R ]\models   \A[\prg{S}/\prg{Q}]$ 
\end{enumerate}
We will be able to decide this when we study the examples. But I think the answer will be no to both.

\begin{lemma}[Preservation of validity of simple assertions]
For any simple assertion $\SA$, runtime configurations $\sigma$,...
\begin{itemize}
\item $\sigma \models \SA$ \ \ if and only if \ \  for any $\M$, $\M'$. \, $\M\mkpair \M', \sigma \models\SA$.
\end{itemize}
\end{lemma}
 
\begin{lemma}[Assertions are classical]
For all runtime configurations $\sigma$, and   assertions $\A$ and $\A'$, and modules
$\M$, $\M'$,
we have
\label{lemma:simple_assertions_classical}
\begin{itemize}
\item
$\M\mkpair \M', \sigma \models \A$ or  $\M\mkpair \M', \sigma \models \neg\A$
\item
$\M\mkpair \M', \sigma \models \A \wedge \A'$ \SP if and only if \SP  $\M\mkpair \M', \sigma \models \A$ and  $\M\mkpair \M', \sigma \models \A'$ 
\item
$\$\M\mkpair \M', \sigma \A \vee \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma \A$ or  $\M\mkpair \M', \sigma \A'$ 
\item
$\M\mkpair \M', \sigma\models \A \wedge \neg\A$ never holds.
\end{itemize}
\end{lemma}
\begin{proof} By induction over the structure of $\A$ -- TODO  SD has not yet thought about this, but believes it holds. \end{proof}.

A module $\M$ satisfies an assertion $\A$ if for all modules $\M'$, in all configurations arising from executions of $\M\mkpair\M'$, the asserttion $\A$ holds.

\begin{definition}
\label{def:module_satisfies}
For any module $\M$, and  assertion $\A$, we define:

$\M \models \A$ \IFF  $\forall \M',\sigma\in \Arising{\M\mkpair\M'}. \, \M\mkpair\M', \sigma \models \A$
\end{definition}

