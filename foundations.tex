 
 \subsection*{LATEX mysteries and terminology}
 \begin{enumerate}
 \item
 How can we make the references refer to the Definitions, Lemmas etc
 rather than the section where these appear?
 \begin{quotation}
   \color{orange} KJX:   Not sure what the problem is. I've put labels
   in the definitions and I can use refs to get definition
   numbers~\ref{defONE} and~\ref{def:syntax:classes} --- 
   not ~\ref{secONE} and ~\ref{sec:syntax:classes}, the section
   numbers containing those definions.

   Alternatively there is the ``cleveref'' package
   \url{http://tug.ctan.org/tex-archive/macros/latex/contrib/cleveref/cleveref.pdf}
   where a ``\verb+\cref{foo}+'' can generate both the type and the
   numbner e.g.  ``Definition 3''.  
 \end{quotation}
 
 \item
 Need a nice metavariable for set of addresses, currently it is $R$. Perhaps instead use an enumeration, as eg $\{ \ \alpha_1,...\alpha_n\ \} $
 or $\kappa$?

 \begin{quotation}
 \color{orange} KJX: Hmm, the enumeration is fine. Otherwise $A$?
 $\mathcal{A}$?  Or we could call that set a ``footprint'' and so go
 with $F$ or $\mathcal{F}$\ldots
 \end{quotation}
\item
Find a nice term  to refer to module pairs  (internal, external), and a term for
our version visible states semantics.
 \begin{quotation}
   \color{orange} KJX: ``modules'' and ``modular state semantics''.
   Going to ``modules'' only makes sense with my answer below.
   Other permutations of 
   ``visible module/modular state semantics'' work also work:
     modular visible state; visible modular state; etc\ldots
 \end{quotation}


\item
Better symbols for module linking (currently a $\M\link\M'$), and
for module pairing (currently a $\M\mkpair \M'$) -- perhaps there should not be such an operator, as
it does not create a new module, it is only used in execution ($\M\mkpair \M', \sigma \leadsto \sigma'$)
and in satisfaction of assertions ($\M\mkpair \M', \sigma\models \A$).
\footnote{\toby{TM: I like~$\M \mkpair \M'$ as it suggests the asymmetry of the visible
    state semantics wrt~$\M$ and~$\M'$.}}

 \begin{quotation}
   \color{orange} KJX: I'm so used to $\M\link\M'$ that I can't think
   of an alternative --- or do I recall we used $\M * \M'$ as a
   separating conjunction?

   So I really liked $\M\mkpair \M'$ --- except then I though that I
   couldn't remember which was the module (inside) and which the
   anti-module (the outside).  For some reason I thought outside would 
   go first.  Then I realised, it's easy, cos $\M$ is always the
   module, and $\M'$ is the antimodule.

   At which point I though: OK so let's just write $\M$ as the module,
   and given any $\M$, then $\M'$ (or $\overline{\M}$ or I guess
   \textbf{out}($\M$)) for the antimodule.

   The only thing I think this loses is that the $\M\mkpair \M'$
   syntax, also like a seperating conjunction, is sort of
   self-framing: $\M\mkpair \M'$ encompasses the universe of modules.
   Whereas the other way around, we'd need a (implicit) universe of
   all modules $\mathcal{U}$, and then define $\M' \triangleq
   \mathcal{U} - \M$  If we went with $\M'$ then Sophia couldn't use
   $\M''$ and friends --- have to write \texttt{N} and \texttt{O} for other
   modules?

   I think the only change I could see in the whole document was that
   lemma~\ref{lemma:module_pair_execution} is subsumed into
   lemma~\ref{lemma:linking:properties}. 
 \end{quotation}


 \end{enumerate}


\section{Overview of our approach}

In this section we give a brief overview of the most salient features of our approach, and give a full exposition in the next two sections.

% As we already stated, this work is devoted to the specification of code in the open world. For these we propose what we call {\em holistic specifications.}

We claim that the most pertinent aspects of behaviour in the open world
are   in terms of  {\em necessary} conditions (\eg what can cause -- what are necessary conditions for --
 the balance of an account to decrease), rather than sufficient conditions (\eg the owner of an account may
 call the \prg{transfer} function, and as a result the balance decreases).
Such necessary conditions are not attached to particular function calls or program points; they apply
throughout program execution.
Therefore, they are expressed through  {\em invariants} that can be observed throughout the lifetime of a program, rather than at specific points in program execution.

In our approach we represent code through modules ($\M$); these are repositories of class definitions (we use classes, because we concentrate on class-based, object-oriented programming; but we believe that the ideas are also applicable to other paradigms.)

The invariants are in the form of holistic assertions $\A$. We concentrate on what it means for a module to satisfy an assertion $\A$; we model this through the judgment $\M \models \A$.
%The judgment $\M \models \A$
This holds if for all further modules $\M'$ and in  all runtime configurations $\sigma$ which may be obseved through execution of the code of $\M$ combined with that of $\M'$, the assertion $\A$ is satisfied. More formally, we define:\\
$~ \strut  \hspace{1.3in} \M \models \A \ \ \  \ \ \ \mbox{             if               } \ \ \  \ \ \   \forall \sigma\in\Arising {\M \mkpair  {\M'}}. \ \M \mkpair  {\M''}, \sigma \models \A$.\\
 In that sense, module {\M'}  represents all possible clients of {\M}; and as it is arbitrarily chosen, it reflects the open world nature of our specifications.

Note that when we consider $\M \mkpair  {\M'}$, we distinguish between $\M$ the module
whose code  is supposed to satisfy the assertion, and $\M'$, the module which exercises
the functionality of $\M$. We call $\M$ the {\em internal} module, while $\M'$ is the {\em external}
or {\em potentially adversarial} module. When examining program executions, we are interested
 in those runtime configurations which are {\em external} to module $\M$, \ie those where the
 executing object (\ie the current receiver) comes from module \M'.
 \footnote{\toby{TM: This looks like an \emph{excellent} way to handle this. Bravo. SD: :-)}}
 In  that sense, our approach is similar to that of visible states semantics, whithout, however the need to consider issues
around different objects of the same class or re-entrancy.\footnote{TODO: add references here.}

The assertions expressed in $\A$  encompass concepts found inF
 standard program specification languages, temporal and spacial operators, and operators which talk about the control structures.
Thus we support assertions which reflect on the contents of local variables
 and of objects  (\eg $\prg{x}.\f1 > \prg{this}.\f2$), assertions which talk about objects being accessible from other objects
(\eg $\CanAccess{\x}{\y}$), about the change of some property
(\eg $\Changes{\x.\f}$, about some property   holding in the future   or in the past
(\eg $\Future \A$  or $\Past \A$), some property being observable within a subset of the current state
( $\Using{\A}{S}$), and the next call in the control ($\Calls {\x} {\y} {\m} {\z}$). Note the parallels with
some concepts from object capabilities ($\CanAccess{\_}{\_}$  for  permission and $\Changes{\_}$ for authority)
as well as temporal logic ($\Future \A$  and $\Past \A$), and the relation of
our spatial connective ($\Using{\A}{S}$)  with effect systems.\footnote{TODO: add references here.}  Whilst 
many  individual
features of our specification language can  be found also in other works, we
%claim that their  combination as well as
%their application in the specification of open systems are novel.
argue that their power and novelty for specifying open systems lies in their careful
  combination. 

The rest of the paper is organized as follows: Section~\ref{sect:LangOO} defines a small oo language,  \LangOO, in terms of its  syntax, the structure of its runtime configurations $\sigma$, and its operational semantics in terms of a judgment with   the form $\M \mkpair \M', \sigma \leadsto \sigma'$. Section \ref{sect:assertions} gives the full definition of assertions $\A$,   when assertions are valid in given runtime configurations in terms of a judgment with   the form $\M \mkpair \M', \sigma \models \A$, and finally define modules' adherence to assertions  in terms of a judgment with   the form $\M \models \A$.


\section{The language \LangOO}
\label{sect:LangOO}

\subsection{Modules and Classes}
\label{secONE}

\LangOO programs are described through modules, which are repositories of code. Since we study class based oo languages,
code is represented as classes, and  modules are mappings from  identifiers to class  descriptions.

\begin{definition}[Modules]
\label{defONE}
We define $\syntax{Module}$ is  the set of mappings from identifiers to class descriptions (the latter defined in Definition \ref{def:syntax:classes}):\\  % to force line break

\begin{tabular}  {@{}l@{\,}c@{\,}ll}
\syntax{Module} \ \  &  \   $\triangleq $  \ &
   $ \{ \ \ \M \ \ \mid \ \  \M: \ \prg{Identifier} \   \longrightarrow \
  \  \syntax{ClassDescr}     \  \    \}$
 \end{tabular}
\end{definition}



%\paragraph{Classes}

Class definitions, as defined   below,
consist of field and method definitions.
Note that \LangOO is untyped. Method bodies consist of sequences of statements;
these can be field read or field assignments, object creation,   method calls, and return statements.
All else, \eg booleans, conditionals, loops,  can be encoded.

Note also that field read or write is only allowed if the target object is \prg{this} -- as, \eg, can
  in Smalltalk -- this is encapsulation: the syntax allows an object to read/write its own fields, but
   forbids it from reading/writing any other object's fields.

\label{sec:syntax:classes}


\begin{definition}[Classes]
\label{def:syntax:classes}
We define the syntax of class descriptions below.

\begin{tabular}{lcll}
 \syntax{ClassDescr}   &   \BBC  &     \kwN{class}  \syntax{ClassId}    \lb\,  $($\ \kw{field} \f\ $)^*$ \
 $($  \kwN{method}\ \syntax{MethBody}\ $)^*$   \ \rb
\\
\syntax{MethBody} &\BBC&
       \m\lp \x$^*$\rp     \lb\, \syntax{Stmts}  \,
    \rb
 \\
 \syntax{Stmts}  &\BBC&  \syntax{Stmt}     ~\SOR~  \syntax{Stmt} \semi \syntax{Stmts} \\
\syntax{Stmt}    &\BBC&
       \kw{this}.\f {\kw{:=}} \x   ~\SOR~  \x{\kw{:=}}  \kw{this}.\f    ~\SOR~        \x  {\kw{:=}} \x.\m\lp \x$^*$\rp  \\
       & &    ~\SOR~     \x  {\kw{:=}}     \newKW\, \c\,\lp \x$^*$\rp   ~\SOR~
   \returnKW \,  \x   \\
 \x, \f, \m &\BBC&  \prg{Identifier}
 \end{tabular}

  \vspace{.03in}
  \noindent
 where we use metavariables as follows:
 $\x \in  \syntax{VarId} \ \ \  \f \in  \syntax{FldId} \ \ \  \m \in  \syntax{MethId} \ \ \  \c \in  \syntax{ClassId}$
\end{definition}


We define  method lookup function, $\mathcal{M}$ which returns the corresponding method definition given a class \c\ and a method identifier \m.


 \begin{definition}[Lookup] For a class identifier \prg{C}  and a method identifier \prg{m} : $ ~ $ \\

\noindent
$
\Meths {} {\prg{C}} {m}       \triangleq  \ \left\{
\begin{array}{l}
                        \m\, \lp \p_1, ... \p_n \rp \lb stms   \rb\\
\hspace{0.5in} \mbox{if}\  \M(\prg{C}) =   \kwN{class}\, \prg{C}\, \  \lb ...   \kwN{method}\ ...\  \m\, \lp \p_1, ... \p_n \rp \lb stms  \rb  ... \ \rb.
\\
\mbox{undefined},  \ \ \ \mbox{otherwise.}
\end{array}
                    \right.$

  \end{definition}

\subsection{The Operational Semantics of \LangOO}
\label{formal:semantics}

We will now define execution of \LangOO code.
We start by  defining the  runtime entities, and runtime configurations, $\sigma$, which consist of stacks of frames and heaps.
 The frames are pairs consisting of a continuation, and a mapping from identifiers to values.
The continuation represents the code to be executed next, and the mapping gives meaning
to the formal and local parameters.

\begin{definition}[Runtime Entities]
We define  addresses, values, frames, stacks, heaps and runtime configurations.

\begin{itemize}
\item
We take addresses to be an  enumerable set,  \prg{Addr}, and use the identifier $\alpha\in \prg{Addr}$ to indicate addresses.
\item
Values, $v$, are either addresses, or sets of addresses or null:\\
 $~ ~ ~ \ v \in \{ \prg{null} \} \cup \prg{Addr}\cup {\mathcal P}( \prg{Addr})$.
\item
  Continuations are either   statements  (as defined in Definition~\ref{def:syntax:classes}) or a marker, \x {\kw{:=}} $\bullet$, for a nested call followed by
  statements to be executed
  once the call returns.  


\begin{tabular}{lcll}
\syntax{Continuation} &\BBC&   \syntax{Stmts} ~\SOR~   \x {\kw{:=}} $\bullet$ \semi\ \syntax{Stmts} \\
 \end{tabular}

\item
Frames, $\phi$, consist of a code stub  and a  mapping from identifiers to values:\\  $~ ~ ~ \ \phi \ \in\ \syntax{CodeStub} \times \prg{Ident} \rightarrow Value$,
\item
Stacks,  $\psi$, are sequences of frames, $\psi\ ::=   \phi \ | \ \phi\cdot\psi$.
\item
Objects consist of a class identifier, and a partial mapping from field identifier to values: \\  \ $~ ~ ~ \ Object\ = \ \prg{ClassID} \times (\prg{FieldId} \rightarrow Value)$.
\item
Heaps, $\chi$, are mappings from addresses to objects:\  \  $\chi\ \in\ \prg{Addr} \rightarrow Object$.
\item
Runtime configurations, $\sigma$, are pairs of stacks and heaps, $\sigma\ ::=\ (\ \psi, \chi\ )$.
\end{itemize}

\end{definition}


Note that values may be sets of addresses. Such values are never part of the execution of \LangOO, but are used to give semantics to assertions -- we shall see that in Definition \ref{def:valid:assertion}.



Next, we define the interpretation of variables (\x) and   field look up  (\this.\f) 
in the context of frames, 
heaps and runtime configurations; these interpretations are used to define the operational semantics and  also  the
validity of assertions, later on in Definition \ref{def:valid:assertion}:

\begin{definition}[Interpretations]
We first define lookup of fields and classes, where $\alpha$ is an address, and \f\, is a field identifier:
\begin{itemize}
\item
$\chi ({\alpha},{\f})$ $\triangleq$  $fldMap({\alpha},{\f})$\ \ \ if \ \ $\chi(\alpha)=(\_, fldMap)$.
\item
$\ClassOf {\alpha} {\chi} $ $\triangleq$ $\c$\  \ \ if \ \ $\chi(\alpha)=(\c,\_)$
\end{itemize}

\noindent
We now define interpretations  as follows:

\begin{itemize}
\item
$\interp {\x}{\phi} $ $\triangleq$ $\phi(\x)$
\item
$\interp {\this.\f}{(\phi,\chi)} $ $\triangleq$ $v$, \ \ \ if \ \ $\chi(\phi(\this))=(\_, fldMap)$ and $fldMap(\f)$=$v$

\end{itemize}

\noindent
For ease of notation, we also use shorthands as below:
\begin{itemize}
\item
$\interp {\x}{(\phi\cdot\psi,\chi)} $ $\triangleq$ $\interp {\x}{\phi} $
\item
$\interp {\this.\f}{(\phi\cdot\psi,\chi)} $ $\triangleq$ $\interp  {\this.\f}{(\phi,\chi)} $
\item
$\ClassOf {\alpha} {(\psi,\chi)} $ $\triangleq$ $\ClassOf {\alpha} {\chi} $
\end{itemize}

\end{definition}

In the definition of the operational semantics of \LangOO we use the following notations for lookup and updates of runtime entities :

\begin{definition}[Lookup and update of runtime configurations]
We define convenient shorthands for looking up in  runtime entities.
%We assume that
% $\sigma$ consists of components so that $\sigma$ = $(\phi.\sigma', \chi, \prg{contn} )$.
\begin{itemize}
\item
Assuming that $\phi$ is the tuple  $(\prg{stub}, varMap)$, we use the notation  $\phi.\prg{contn}$ to obtain \prg{stub}.
\item
Assuming a value v, and that $\phi$ is the tuple  $(\prg{stub}, varMap)$, we define $\phi[\prg{contn}\mapsto\prg{stub'}]$ for updating the stub, \ie
$(\prg{stub'}, varMap)$.   We use  $\phi[\x \mapsto v]$  for updating the variable map, \ie  $(\prg{stub}, varMap[\x \mapsto v])$.
\item
Assuming a heap $\chi$, a value $v$, and   that $\chi(\alpha)=(\c, fieldMap)$,
we use $\chi[\alpha,\f \mapsto v]$ as a shorthand for updating the object, \ie $\chi[\alpha \mapsto (\c, fieldMap[\f \mapsto v]]$.
\end{itemize}

\end{definition} 



\begin{figure*}
$\begin{array}{l}
\inferenceruleNN {methCall\_OS} {
%\sigma \ = \  (\ \phi\cdot\psi,\ \chi\ )
\\
\phi.\prg{contn}\ =\ \x {\kw{:= }} \x_0.\m \lp \prg{par}_1, ... \prg{par}_n \rp \semi \prg{stms}
\\
\interp{\x_0}{\phi} = \alpha
\\
\Meths {} {\ClassOf {\alpha} {\chi}} {\m} \  =  \ \m\lp par_1, \ldots par_n \rp \lb \prg{stms}_1   \rb
  \\
 \phi''\ =\  (\  \prg{stmts}_1,\ \ (\ \this \mapsto \alpha, 
  \prg{par}_1 \mapsto  \interp{\x_1}{\phi}, \ldots \prg{par}_n \mapsto  \interp{\x_n}{\phi}\ ) \ )
}
{
 \M,\, (\ \phi\cdot\psi,\ \chi\ )\ \ \leadsto\  \ (\ \phi''\cdot\phi[\prg{contn}\mapsto\x  \kw{:=} \bullet \semi \prg{stms}] \cdot\psi,\ \chi\ )
}

\\ \\
\inferenceruleNN {varAssgn\_OS} {
 \phi.\prg{contn} \ = \ \x  {\kw{:= }}   \this.\f \ \semi \prg{stms}
}
{
 \M,\,  (\ \phi\cdot\psi, \chi\ )\ \ \leadsto\  \ (\ \phi[ \prg{contn} \mapsto \prg{stms}, \x\mapsto \interp{\this.\f}{\phi,\chi}] \cdot\psi,\ \chi\  )
}
\\
\\
\inferenceruleNN{fieldAssgn\_OS} {
 \phi.\prg{contn}\ =\  \this.\f  \kw{:=} \x  \semi \prg{stms}
}
{
 \M,\,  (\ \phi\cdot\psi, \chi\  )\ \ \leadsto\  \ (\ \phi[\prg{contn}\mapsto  \prg{stms} ] \cdot\psi, \chi[\interp{\this}{\phi},\f \mapsto \interp{\x}{\phi,\chi}]\  )
}
\\
\\
\inferenceruleNN {objCreate\_OS} {
 \phi.\prg{contn}\ =\  \x  \kw{:=} \kwN{new }\, \c \lp \x_1, ... \x_n \rp  \semi \prg{stms}
 \\
 \alpha\ \mbox{new in}\ \chi
 \\
\f_1, .. \f_n\ \mbox{are the fields declared in } \M(\c)
}
{
 \M,\,  (\ \phi\cdot\psi, \chi\ )\ \ \leadsto\  \ (\ \phi[\prg{contn}\mapsto  \prg{stms},\x \mapsto \alpha\ ] \cdot\psi, \ \chi[\alpha \mapsto (\c,\f_1 \mapsto \interp{\x_1}{\phi},  ... \f_n \mapsto \interp{\x_n}{\phi}  ) ]\ )
}
\\
\\
\inferenceruleNN {return\_OS} {
 \phi.\prg{contn}\ =\   {\kwN{return }}\, \x  \semi \prg{stms}\ \  \ or\  \ \  \phi.\prg{contn}\ =\   {\kwN{return}}\, \x
 \\
\phi'.\prg{contn}\ =\  \x' \kw{:=} \bullet  \semi \prg{stms}'
}
{
 \M,\,  (\ \phi\cdot\phi'\cdot\psi, \chi\ )\ \ \leadsto\  \ (\ \phi'[\prg{contn}\mapsto  \prg{stms'},\x' \mapsto \interp{\x}{\phi}] \cdot\psi, \ \chi \ )
}
\end{array}
$
\caption{Operational Semantics}
\label{fig:Execution}
\end{figure*}

Execution of statement has   form $\M, \sigma \leadsto \sigma'$, it is defined in figure \ref{fig:Execution}.

\begin{definition}[Execution] of one or more steps is defined as follows:

\begin{itemize}
     \item
   The relation $\M, \sigma \leadsto \sigma'$, it is defined in Figure~\ref{fig:Execution}.
   
   \item
   $\M, \sigma \leadsto^* \sigma'$ holds, if a) $\sigma$=$\sigma'$, or b) there exists a $\sigma''$ such that
   $\M, \sigma \leadsto^* \sigma''$ and $\M, \sigma'' \leadsto \sigma'$.
 \end{itemize}

\end{definition}

\footnote{Toby had added that following but I do not see what we need it for. \toby{We defer the definition of initial configurations to Definition~\ref{defn:initial-and-arising} later.}}

\subsection{Definedness of execution, and extending configurations}

Note that interpretations and executions need not always be defined.
For example, in a configuration whose top frame does not contain \x\,  in its domain, $\interp {\x}{\phi} $ is undefined. We define the relation $\sigma \subconf \sigma'$ to express that   $\sigma$ has more information than $\sigma'$, and then prove that more defined configurations preserve interpretations:

\begin{definition}[Extending runtime configurations]
The relation $\subconf$   is defined on runtime configurations as follows. Take arbitrary
configurations $\sigma$, $\sigma'$, $\sigma''$, frame $\phi$, stacks $\psi$, $\psi'$,  heap $\chi$, address $\alpha$ free in $\chi$, value $v$ and object $o$, and define $\sigma  \subconf \sigma'$ as the smallest relation such that:

\begin{itemize}
\item
$\sigma  \subconf \sigma$
\item
$(\phi[\x \mapsto v]\cdot \psi, \chi) \subconf  (\phi\cdot \psi, \chi)$
\item
$(\phi\cdot\psi\cdot\psi', \chi) \subconf  (\phi\cdot \psi, \chi)$
\item
$(\phi, \chi[\alpha \mapsto o) \subconf  (\phi\cdot \psi, \chi)$
\item
$\sigma'  \subconf \sigma''$ and $\sigma''  \subconf \sigma$ imply $\sigma'  \subconf \sigma$
\end{itemize}
\end{definition}



\begin{lemma}[Preservation of interpretations and executions]
If $\sigma'  \subconf \sigma$, then

\begin{itemize}
\item
If $\interp {\x}{\sigma}$ is defined,\ \  then $\interp {\x}{\sigma'}$=$\interp {\x}{\sigma}$.
\item
If $\interp {\this.\f}{\sigma}$ is defined,\ \  then $\interp {\this.\f}{\sigma'}$=$\interp {\this.\f}{\sigma}$.
\item
If $\ClassOf {\alpha} {\sigma} $  is defined, \ \ then  $\ClassOf {\alpha} {\sigma'} $  = $\ClassOf {\alpha} {\sigma} $.
\item
If $\M, \sigma \ \leadsto^*\ \sigma''$, \ \ ithen     \ \ there exists a $\sigma''$, so that\ $\M, \sigma'\ \leadsto^*\ \sigma'''$
and $\sigma''' \subconf \sigma''$.
\end{itemize}
\end{lemma}




\subsection{Module linking}

When studying validity of assertions in the open world we are concerned with whether   the  module
under consideration makes  a certain guarantee when executed in conjunction with other modules. To answer this, we
 need the concept of linking other modules to the module  under consideration.
 Linking, $\link$,  is an operation that takes two modules, and creates a module which corresponds  to the union of the two.
 %We use the concept of module linking in order to model the open world, where our module $\M$ whose code we know, will be executed together with further modules whose code we do not know.
We place some conditions for module linking to be defined: We require that the two modules do not contain implementations for the same class identifiers,

\begin{definition}[Module Linking]

The linking operator\  \ $\link:\  \syntax{Module} \times  \syntax{Module} \longrightarrow \syntax{Module}$ is defined as follows:

$
\M \link \M{'}  \ \triangleq  \ \ \left\{
\begin{array}{l}
                        \M\ \link\!_{aux}\ \M{'},\ \ \   \hbox{if}\  \ dom(\M)\!\cap\!dom(\M')\!=\!\emptyset\\
\mbox{undefined}  \ \ \ \mbox{otherwise.}
\end{array}
                    \right.$

and where,
\begin{itemize}
     \item
   For all  $\prg{C}$: \ \
   $(\M\ \link\!_{aux}\ \M')(\prg{C})\  \triangleq  \ \M(\prg{C})$  if  $\prg{C}\in dom(\M)$, and  $\M'(\prg{C})$ otherwise.
 \end{itemize}
\end{definition}

The lemma below says  that linking is associative and commutative, and preserves execution.

\begin{lemma}[Properties of linking]
 For any modules $\M$,   $\M'$ and $\M''$, and runtime configurations $\sigma$, and $\sigma'$ we have$:$
 \label{lemma:linking:properties}

 \begin{itemize}
     \item
     $(\M \link \M')\link \M''$ = $\M \link (\M' \link \M'')$.
    \item
      $\M \link \M'$  = $\M' \link\M$.
      \item
      $\M, \sigma \leadsto \sigma'$, and $\M\link \M'$ is defined, \  \  implies\ \   $\M\link \M', \sigma \leadsto \sigma'$
   \end{itemize}

 \end{lemma}

 \subsection{Module pairs and visible states semantics}

A module $\M$ adheres to an invariant assertion  $\A$, if it satisfies
$\A$ in all runtime configurations that  can be reached through execution of the code of $\M$ when linked to that
of {\em any other} module $\M'$, and
which are {\em external} to $\M$. We call external to $\M$ those
configurations which are currently executing code which does not come from $\M$. This allows the code in $\M$ to break
the invariant internally and temporarily, provided that the invariant is observed across the states visible to the external client $\M'$.

Therefore, we define execution in terms of an internal module $\M$ and an external module $\M'$, through the judgment $\M \mkpair \M', \sigma \leadsto \sigma'$, which mandates that $\sigma$ and $\sigma'$ are external to $\M$, and that there exists an execution which leads from $\sigma$ to $\sigma'$ which leads through intermediate configurations
$\sigma_2$, ...  $\sigma_{n+1}$ which are all internal to $\M$, and thus unobservable from the client.
In a sense, we "pretend" that all calls to functions from $\M$ are executed atomically, even if they involve several intermediate,
internal steps.


\begin{definition}
Given runtime configurations $\sigma$,  $\sigma'$,  and module $\M$ $\M'$ we define
\label{def:module_pair_execution} trough execution,
\begin{itemize}
\item
$\M \mkpair \M', \sigma \leadsto \sigma'$ \IFF
there exist  $n\geq 2$ and runtime configurations $\sigma_1$,  ...
$\sigma_n$, such that
\begin{itemize}
\item
$\sigma$=$\sigma_1$,\ \  \ \ and\ \ \ \ $\sigma_n=\sigma'$.
\item
$\M \link \M', \sigma_i \leadsto \sigma_{i+1}'$,\  \  for $1\leq i \leq n\!-\!1$
\item
$\ClassOf{\interp {\this} {\sigma}} {\sigma}\not\in dom({\M})$,  \ \  \ \ and\ \ \ \
$\ClassOf{\interp {\this} {\sigma'}} {\sigma'} \not\in dom({\M})$,
\item
 $\ClassOf{\interp {\this} {\sigma_i}} {\sigma_i} \in dom({\M})$,\ \ \ \ for $2\leq i \leq n\!-\!2$
\end{itemize}
\end{itemize}

\end{definition}

In the definition above $n$ is allowed to have the value $2$. In this case the final bullet is trivial and  there exists a direct, external transition from $\sigma$ to $\sigma'$.  Our definition is related to the concept of visible states semantics, but differs in that visible states semantics select the configurations at which an invariant is expected to holds, while we select the states which are considered for executions which are expected to satisfy an invariant. Our assertions can talk about several states (through the use of the $\Future {\_}$ and $\Past{\_}$ connectives), and thus, the intention of ignoring some intermediate configurations can only be achieved if we refine the concept of execution.\footnote{Explain better? Use the term "atomic"?}


The following lemma states that linking external modules preserves execution

\begin{lemma}[Linking modules preserves execution]
\label{lemma:module_pair_execution}
For any modules $\M$, $\M'$, and $\M''$, whose domains are pairwise disjoint, and runtime configurations $\sigma$, $\sigma'$,

\begin{itemize}
\item
 $\M \mkpair \M', \sigma \leadsto \sigma'$  implies $\M \mkpair (\M'\link\M') ,\sigma \leadsto \sigma'$.
\item
  $\M \mkpair \M', \sigma \leadsto \sigma'$  implies
$(\M\link\M'') \mkpair \M' , \sigma \leadsto \sigma'$.

\end{itemize}
\end{lemma}

\begin{proof} For the second guarantee  we use the fact that   $\M \mkpair \M', \sigma \leadsto \sigma'$ implies that all
intermediate configurations are internal to $\M$ and thus also to $\M\link\M''$.
\end{proof}

We can now answer the question as to which runtime configurations are pertinent when judging a module's
adherence to an assertion.
First, where does execution start? We define {\em initial} configurations to be those which may contain arbitrary code stubs, but which contain no objects. Objects will be created, and further methods will be called through execution of the code in $\phi.\prg{contn}$. From such initial configurations, executions of code from $\M \mkpair \M'$ creates a set of {\em arising} configurations, which, as we will see in Definition \ref{def:module_satisfies}, are pertinent when judging $\M$'s  adherence to assertions.

\begin{definition}[Initial and arising Configurations] are defined as follows: \label{defn:iniial-and-arising}

\begin{itemize}
     \item
   $\Initial {(\psi,\chi)}$, \ \ if \ \ $\psi$ consists of a single frame $\phi$ with $dom(\phi)=\{ \this, \caller \}$, and \\
    $\ \strut \hspace{1.2in} $ $\interp {\caller}{\phi}$= $\interp {\this}{\phi}$=\nullK, and $dom(\chi)$=$\emptyset$.
 \item
 $\Arising  {\M\mkpair\M'} \ = \ \{ \ \sigma \ \mid \ \exists \sigma_0. \ [\  \Initial{\sigma_0} \  \ \wedge\ \  \M\mkpair\M', \sigma_0 \leadsto^* \sigma \ \ ] \ \ \} $
 \end{itemize}

\end{definition}




\section{ Assertions}
\label{sect:assertions}

\subsection{The syntax of Expressions and Assertions}
Assertions, $\A$ allow us to reflect over the current runtime configuration, but also over possible future and past configurations, and over
the call chains.  We define the syntax of assertions beliow.
We support assertions $\CanAccess{\_}{\_}$  (permission)
and   $\Changes{\_}$ (authority). \footnote{Note that they are slightly different
assertions to those we had in the past.}
We also add temporal modifiers, where $\Future \A$ expresses that $\A$ will hold at some future point,
$\Past \A$ expresses that $\A$ held at some point in the past.
We also add a {\em spatial modifier}, $\Using{\A}{S}$, which expresses that assertion $\A$ holds in
the sub-configurations determined by the witness \prg{S}.


\begin{definition}[Assertions]The syntax of simple expressions $\SE$) and assertions ($\A$) is:
\label{def:assertions}

 $\begin{array}{lcl}
  \SE & ::= &  \prg{true}  \ \mid\ \prg{false}  \    \mid\ \prg{null}  \ \mid \ \x  \ \mid \ \SE.\f    \ \mid \ \SE.\f^n \  \\
 ~ \\
\A &\ ::=\  &   \SE  \ \mid \ \SE > \SE \ \mid \  \SE=\SE  \ \mid \ \SE \equiv \SE\ \mid \   \SE:\prg{ClassId}  \ \mid \
    \SE\in\prg{S}   \ \mid  \ \A \rightarrow \A  \\
 &   &  \exists \x.\A  \ \mid \  \exists \prg{S}:SET.\A  \ \mid \  \exists fs:FLD^k.\A
 \ \mid \  \exists k:\mathbb{N}.\A
\\
 &    & \CanAccess x y \ \mid\  \ \Changes e \ \mid\  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}} \ \mid\  \  \Future \A  \ \mid \  \Past \A \ \mid \ \Using \A \prg{S }
% \\
 \\
  &   &  \A \wedge \A  \ \mid\  \ \A \vee \A  \ \mid\  \ \neg A   \ \mid\  \ \forall \x.\A  \ \mid \  \forall \prg{S}:SET.\A  \ \mid \  \forall fs:FLD^k.\A
 \ \mid \  \forall k:\mathbb{N}.\A
\end{array}$


\end{definition}

Note that the operators $\wedge$, $\vee$,  $\neg$ and $\forall$  could have been defined  through the usual shorthands, \eg, $\neg \A$ is short for
$\A \rightarrow \ff$ \etc, but here we give full definitions instead.
 Validity of assertions has the format $\M\mkpair \M', \sigma \models \A$, where  $\M$ is the internal module, whose internal workings
 are opaque to the external, client module $\M'$.

\subsection{Configuration adaptation and configuration restrictions}
In order to define whether a runtime configuration satisfies an assertion we need two auxiliary concepts:
the adaptation of a runtime configuration to another one, and the restriction of a runtime configuration to only the set of objects from a
given set.

We need adaptation to deal with time, and the corresponding changes of scope. For example, the assertion
$\Future {\x.\f=\prg{3}}$, is satisfied if in some {\em future} configuration, the field  \f\, of the object that is pointed at by \x\, in the {\em current} configuration has the value \prg{3}; note that in the future  configuration, \x\, may be pointing to a different object, or may
even no longer be in scope (\eg if a nested call or a nesting call is executed).
Therefore, we introduce the operator \  $\adapt\;$,  \ \ which combines runtime configurations: $\sigma \adapt \sigma'$ adapts the second configuration to the top frame's view of the former: it returns a new configuration whose stack has  the top frame as taken from $\sigma$ and where the \prg{contn} has been consistently renamed, while the heap is taken from $\sigma'$. This allows us to interpret expressions  in the newer (or older) configuration $\sigma'$ but with the variables bound according to the top frame from $\sigma$; \eg we can obtain that value of \prg{x}.\prg{f} in configuration  $\sigma'$ even if \prg{x} was out of scope. The consistent renaming of the code allows the correct modelling of execution (as needed,   for the semantics of  nested time assertions, as \eg in $\Future {\x.\f=\prg{3} \wedge \Future {\x.\f=\prg{5}}}$


 \begin{definition}[Adaptation on Runtime Configurations]  The operator $\adapt$\ \  is a binary operator on runtime configurations.
 \label{def:config:adapt}
 $~ $

\begin{itemize}
\item
$\sigma \adapt \sigma' \triangleq (\phi''\cdot\psi',\chi')$  \IFF $\sigma=(\phi\cdot\_,\_)$, and $\sigma'= (\phi'\cdot\psi',\chi')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $
$\phi$=$(\prg{contn},varMap)$, and $\phi'$=$(\prg{contn}',varMap')$, and
 \\
$\ \strut \ \ \hspace{1.45in} $     % $\phi''$ such that
  $\phi''=(\, \prg{contn}'[\prg{zs}/\prg{zs}' ],\,varMap'[\prg{zs}'\mapsto varMap(\prg{zs})]\, ) $, where
 \\
$\ \strut \ \ \hspace{1.45in} $
\prg{zs}=$dom(varMap)$, and
 \\
$\ \strut \ \ \hspace{1.45in} $      $\prg{zs}'$ is a set  of variables with  the  same cardinality as \prg{zs}, and
 \\
$\ \strut \ \ \hspace{1.45in} $   all variables in
$\prg{zs}'$  are fresh in $varMap$ and in $varMap'$.


\end{itemize}

\end{definition}

 On the other hand, an assertion of the form $\Using{A}{S}$ promises that $\A$ holds in subconfiguration, whose heap is restrcted to the objects from \prg{S}.

 \begin{definition}[Restriction on Runtime Configurations]  The restriction operator~$\;\restrct{} {} $ applied to a runtime configuration $\sigma$ and a set $R$ is defined as follows:
 \label{def:config:restrct}
 $~ $

\begin{itemize}
\item
$\restrct {\sigma}{\prg{S}} \ \triangleq \ (\phi, \chi')$, \IFF  $\sigma$=$(\phi,\chi)$, \ and  \  $dom(\chi')=\interp {\prg{S}} {\sigma}$, and  \\
$\ \strut \ \ \hspace{1.2in} $
% THE BELOW IS WRONG!
% $\forall \x, \f_1, ... \f_n.$\ $\interp {\x.\f_1....\f_n}{\sigma} = \interp {\x.\f_1....\f_n}{\sigma_S}$.
 $\forall \alpha\!\in\!dom(\chi').[ \ClassOf {\alpha} {\chi'} =  \ClassOf {\alpha} {\chi}\ \wedge \ \forall \f.  \chi'(\alpha,\f)=\chi(\alpha,\f)]$.
\end{itemize}
\end{definition}

\subsection{Satisfaction of assertions}



\begin{definition}[Interpretations for simple expressions]

For any runtime configuration, $\sigma$, and any $k\in \mathbb{N}$, and any simple expression, $\SE$, we define its interpretation as follows:

\begin{itemize}
     \item
  $\interp {\prg{true}}{\sigma}$ $ \triangleq$   \prg{true}, \ and \ \    $\interp {\prg{false}}{\sigma}$ $ \triangleq$ \prg{false}, \ and \ \
   $\interp {\prg{null}}{\sigma}$ $ \triangleq$  \prg{null}
  \item
  $\interp {\x}{\sigma}$ $ \triangleq$ $\phi(\x)$  \ \ if \ \ $\sigma$=$(\phi\cdot\_,\_)$
  \item
  $\interp {\SE.\prg{f}}{\sigma}$ $ \triangleq$ $\chi({\interp {\SE}{\sigma}}, \prg{f})$  \ \ if \ \ $\sigma$=$(\_,\chi)$
   \item
     $\interp {\SE.\prg{f}^0}{\sigma}$ $ \triangleq$  $\interp {\SE}{\sigma}$, \ \ \ and \ \ \ $\interp {\SE.\prg{f}^{k+1}}{\sigma}$ $ \triangleq$   $\chi({\interp {\SE.\prg{f}^k}{\sigma}})(\prg{f})$, where $\sigma$=$(\_,\chi)$.
   \end{itemize}
\end{definition}

\begin{lemma}[Interpretation corresponds to execution]
For any simple expression $\SE$, runtime configuration $\sigma$, and value $v$:

\begin{itemize}
     \item
  $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M_\emptyset, \sigma[\prg{contn}\mapsto \SE] \leadsto v$,\\
  where $\M_\emptyset$ stands for the empty module.
  \item
   $\interp \SE {\sigma}$ = $v$\ \     if and only if \ \ $\M, \sigma[\prg{contn}\mapsto \SE] \leadsto v$ \ \ \ for any module $\M$ .
   \end{itemize}
   \end{lemma}

   \begin{proof} The  first guarantee is proven structural induction  over the definition of $\SE$.
   The second guarantee  is a corollary of the first guarantee  and of lemma \ref{lemma:linking:properties}.\end{proof}


\begin{definition}[Satisfaction of  Assertions] We define below when a configuration satisfies an assertions. We first extend the definition of interpretation
to simple expressions.
\label{def:valid:assertion}

We first consider simpler assertions which only involve expresssions:

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models\SE$ \IFF  $\interp{\SE}{\sigma}$ = \prg{true}.
\item
$\M\mkpair \M', \sigma \models\SE>\SEPrime$ \IFF $\interp{\SE}{\sigma}$ > $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE=\SEPrime$ \IFF $\interp{\SE}{\sigma}$ = $\interp{\SEPrime}{\sigma}$.
\item
$\M\mkpair \M', \sigma \models\SE\equiv\SEPrime$ \IFF $\SE$ and $\SEPrime$ are textually identical.
\item
$\M\mkpair \M', \sigma \models \SE:\prg{ClassId}$ \IFF $\ClassOf {\interp{\SE}{\sigma}} {\sigma}$ = $\prg{ClassId}$.
\item
$\M\mkpair \M', \sigma \models \SE\in \prg{S}$ \IFF $\interp{\SE}{\sigma}\in \interp{\prg{S}}{\sigma}$.
\end{itemize}

Next, we consider assertions involve existential quantifiers over program variables, field sequences, sets and numbers.

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models \exists x.\A$ \IFF  
$\M\mkpair \M', \sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$ \ for some  $\alpha\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$.\item
$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}\!.\,\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
$\strut ~ \hspace{1.4in} $ for some set of addresses $R\subseteq dom(\sigma)$, and   \prg{Q} free in $\sigma$ and $\A$.

\item
$\M\mkpair \M', \sigma \models  \exists \prg{fs}:\prg{FLD}^k\!.\,\A$ \IFF
$\M\mkpair \M', \sigma \models  \A[\prg{fs}/\prg{f}_1.\f_2.\,...\,\prg{f}_k]$\  for  $k$ field identifiers $\prg{f}_1$,..,$\prg{f}_k$.
\item
$\M\mkpair \M', \sigma \models  \exists \prg{n}:\prg{Nat}.\A$ \IFF  $\M\mkpair \M', \sigma \A[\prg{n}/k]$\ \ for some $k\in\mathbb{N}$.
\item
$\M\mkpair \M', \sigma \models \A \rightarrow \A' $ \IFF  $\M\mkpair \M', \sigma \models \A $ implies $\M\mkpair \M', \sigma \models \A' $
\end{itemize}

And now, we consider the assertions which involve space, time or control:

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models  \CanAccess{\prg{x}}{\prg{y}}$   \IFF  \begin{itemize}
\item
$\interp {\x} {\sigma}$=$\interp {\y} {\sigma}$, or
\item
$\interp {\x.\f} {\sigma}$=$\interp {\y} {\sigma}$  for some field \prg{f},  or
\item
$\interp {\x} {\sigma}$=$\interp {\this} {\sigma}$ and
  $\interp {\y} {\sigma}$=$\interp {\z} {\sigma}$,
\
and \z\ appears in  $\sigma$.\prg{contn}.\footnote{
That is, $\CanAccess{\prg{x}}{\prg{y}}$ expresses that \x has a {\em direct} path to \y.
In more detail, in the current frame,
either \x and \y\, are  aliases, or \x points to an object which has a field 
whose value is the same as \y, or \x is the currently executing object and \y is  
 a local variable or formal parameter which appears in the code in the continuation. 
 %That means, that variables which were introduced into the variable map in order to give meaning to existentially quantified assertions are not considered. 
 }
 \end{itemize}
 \item
 $\M\mkpair \M', \sigma \models   \Changes{\prg{e}}$  \IFF
 $\exists \sigma'.\, [\ \ \M\mkpair \M',\sigma \leadsto \sigma' \ \wedge \interp{e}{\sigma} \neq \interp{e}{\sigma\triangleleft \sigma'} \ \  ]$.
   \item
$\M\mkpair \M', \sigma \models  \Calls{\prg{x},\prg{y},\prg{m},\prg{z}}$ \IFF \
 $\sigma.\prg{contn}$=\prg{u.m(v);\_} for some variables \prg{u} and \prg{v},  \ and \
\\ $\strut ~ \hspace{1.4in} $
$\interp{\prg{this}}{\sigma}$=$\interp{\prg{x}}{\sigma}$, \ and\ $\interp{\prg{y}}{\sigma}$=$\interp{\prg{u}}{\sigma}$,
 \ and\ $\interp{\prg{z}}{\sigma}$=$\interp{\prg{v}}{\sigma}$.
 \item
  $\M\mkpair \M', \sigma \models  \Future \A $
  \IFF
  $\exists \sigma'.\, [\ \ \M\mkpair \M',\phi \leadsto^* \sigma' \ \wedge \M\mkpair \M',\sigma\adapt\sigma' \models \A \ \  ]$,
 \\
$\strut ~ \hspace{1.4in} $  and where $\phi$ is 
so that $\sigma$=$(\phi\cdot\_,\_)$.\footnote{$\M\mkpair \M', \sigma \models  \Future \A $ holds if
$\A$ holds in some configuration $\sigma'$ which arises from execution of $\phi$, where $\phi$ is the top frame of $\sigma$. By requiring that $\phi \leadsto^* \sigma' $ rather than 
$\sigma \leadsto^* \sigma' $ we are restricting the set of possible future configurations to
just those that are caused by the top frame.
Namely, we do not want to also consider the effect of  enclosing function calls. 
This allows us to write more natural specifications
when giving necessary conditions for some future effect. 
}
 \item
 $\M\mkpair \M', \sigma \models  \Past \A $ \IFF
 $\forall \sigma_1, ... \sigma_n. [\ \ \Initial{\sigma_1}\ \wedge \
 \forall i\in[1..n). \M\mkpair \M', \sigma_{i} \leadsto  \sigma_{i+1} \ \wedge \
 \sigma_n=\sigma$
 \\
$\strut ~ \hspace{1.9in} $  $ \longrightarrow \ \ \  \exists j\in [1..n-1).
 \M\mkpair \M', \sigma\adapt\sigma_j  \models \A\ \
 ]$\footnote{past includes the present, perhaps change this}
 \item
 $\M\mkpair \M', \sigma \models \Using \A \prg{S}$
 \IFF
 $\M\mkpair \M', \restrct \sigma {\prg{S}} \models  \A  $.
\end{itemize}

The remaining assertions introduce the remaining logical operators (\ie $\wedge$, $\vee$, $\neg$ and the universal quantifiers). These could be encoded in terms of the preceding operators, but we nevertheless give their meaning explicitly here.

\begin{itemize}
\item
$\M\mkpair \M', \sigma \models  \A \wedge \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
and $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \A \vee \A'$   \IFF  $\M\mkpair \M', \sigma \models  \A $
or $\M\mkpair \M', \sigma \models  \A'$.
\item
$\M\mkpair \M', \sigma \models  \neg\A$   \IFF  $\M\mkpair \M', \sigma \models  \A $
does not hold.
\item
$\M\mkpair \M', \sigma \models \forall x.\A$ \IFF
$\sigma[\prg{z}\mapsto \alpha] \models  \A[\prg{x}/\prg{z}]$ \ for all  $\alpha\in dom(\sigma)$, and   all \prg{z} free in $\sigma$ and $\A$.\item
$\M\mkpair \M', \sigma \models \forall \prg{S}\!\!:\!\!\prg{SET}.\A$ \IFF  $\M\mkpair \M', \sigma[\prg{Q}\mapsto R] \models  \A[\prg{S}/\prg{Q}]$ \\
$\strut ~ \hspace{1.4in} $ for all sets of addresses $R\subseteq dom(\sigma)$, and  all \prg{Q} free in $\sigma$ and $\A$.

\item
$\M\mkpair \M', \sigma \models \forall \prg{fs}\!\!:\!\!\prg{FLD}^k.\A$ \IFF
$\M\mkpair \M', \sigma \models  \A[\prg{fs}/\prg{f}_1.\f_2.\,...\,\prg{f}_k]$\  for  all  field identifiers $\prg{f}_1$,..,$\prg{f}_k$.
\item
$\M\mkpair \M', \sigma \models  \forall \prg{n}:\prg{Nat}.\A$ \IFF  $\M\mkpair \M', \sigma \A[\prg{n}/k]$\ \ for all $k\in\mathbb{N}$.
\end{itemize}\end{definition}

%\noindent
%{\bf Question} SD wonders whether we should have taken the ${\mathcal I}(\M)$ aspect in some of
%the definitions  earlier on.
%For example, should we have defined
%\begin{enumerate}
%\item
%$\M\mkpair \M', \sigma \models \exists x.\A$ \IFF  exist  $\alpha\in dom(\sigma)$, and   \prg{z} free in $\sigma$ and $\A$, \hl{and $\sigma[\prg{z}\mapsto \alpha] \not\models {\mathcal I}(\M)[\prg{this}/\prg{z}]$}  so that
%$\sigma[\prg{z}\mapsto \alpha \models  \A[\prg{x}/\prg{z}]$
%\item
%$\M\mkpair \M', \sigma \models \exists \prg{S}:\prg{SET}.\A$ \IFF
% exists a set of addresses $R\subseteq dom(\sigma)$, and a \prg{Q} free in $\sigma$ and $\A$, so that
%\hl{for all $\alpha\in R$,} for \prg{z}    free in $\sigma$ and $\A$, \hl{we have }
%  \hl{$\sigma[\prg{z}\mapsto \alpha] \not\models {\mathcal I}(\M)[\prg{this}/\prg{z}]$}, and
%$\M\mkpair \M', \sigma[\prg{Q}\mapsto R ]\models   \A[\prg{S}/\prg{Q}]$
%\end{enumerate}
%We will be able to decide this when we study the examples. But I think the answer will be no to both.


We define equivalence of   assertions in the usual sense: two assertions are equivalent if they are satisfied  in
the context of the same configurations.

\begin{definition}[Equivalence and entailments of assertions]
$ ~ $

\begin{itemize}
\item
$\A \equiv \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ if and only if }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\item
$\A \subseteqq \A'\  \IFF\    \forall \sigma.\, \forall \M, \M'. \ [\ \ \M\mkpair \M', \sigma \models \A\ \mbox{ implies }\ \M\mkpair \M', \sigma \models \A'\ \ ].$
\end{itemize}
\end{definition}



\begin{lemma}[Assertions are classical-1]
For all runtime configurations $\sigma$,    assertions $\A$ and $\A'$, and modules $\M$  and $\M'$, we have
\begin{enumerate}
\item
$\M\mkpair \M', \sigma \models \A$\ or\ $\M\mkpair \M', \sigma \models \neg\A$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma \models \A$ and $\M\mkpair \M', \sigma  \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \vee \A'$ \SP if and only if \SP $\M\mkpair \M', \sigma  \models \A$ or  $\sigma \models \A'$
\item
$\M\mkpair \M', \sigma  \models \A \wedge \neg\A$ never holds.
\item
$\M\mkpair \M', \sigma  \models \A$ and  $\M\mkpair \M', \sigma  \models \A \rightarrow \A'$  implies
$\M\mkpair \M', \sigma  \models \A '$.
\end{enumerate}
\end{lemma}
\begin{proof} By application of the corresponding definitions from \ref{def:valid:assertion}.\end{proof}.

\begin{lemma}[Assertions are classical-2]
For     assertions $\A$, $\A'$, and $\A''$ the following equivalences hold
\label{lemma:basic_assertions_classical}
\begin{enumerate}
\item
$ \A \wedge\neg \A \ \equiv \  \prg{false}$
\item
$ \A \vee \neg\A   \ \equiv \  \prg{true}$
\item
$ \A \wedge \A'  \ \equiv \  \A' \wedge \A$
\item
$ \A \vee \A'  \ \equiv \  \A' \vee \A$
\item
$(\A \vee \A') \vee \A'' \ \equiv \  \A \vee (\A' \vee\A'')$
\item
$(\A \vee \A') \wedge \A'' \ \equiv \  (\A \wedge \A')\, \vee\, (\A \wedge \A'')$
\item
$(\A \wedge \A') \vee \A'' \ \equiv \  (\A \vee \A')\, \wedge\, (\A \vee \A'')$
\item
$\neg (\A \wedge \A') \  \ \equiv \  \neg  \A   \vee\, \neg \A''$
\item
$\neg (\A \vee \A') \  \ \equiv \  \neg  \A   \wedge\, \neg \A''$
\item
$\neg (\exists \prg{x}.\A )  \  \ \equiv \  \forall \prg{x}.(\neg  \A)$
\item
$\neg (\exists k:\mathbb{N}.\A )  \  \ \equiv \  \forall  k:\mathbb{N}.(\neg  \A)$
\item
$\neg (\exists \prg{fs}:FLD^k.\A )  \  \ \equiv \  \forall \prg{fs}:FLD^k.(\neg  \A)$
\item
$\neg (\forall \prg{x}. \A)  \  \ \equiv \  \  \exists \prg{x}.\neg(\A )$
\item
$\neg (\forall k:\mathbb{N}. \A)  \  \ \equiv \  \  \exists k:\mathbb{N}.\neg(\A )$
\item
$\neg (\forall \prg{fs}:FLD^k. \A)  \  \ \equiv \  \  \exists \prg{fs}:FLD^k.\neg(\A )$
\end{enumerate}
\end{lemma}
\begin{proof}
All points follow by application of the corresponding definitions from \ref{def:valid:assertion}.
 \end{proof}

Notice that satisfaction is not preserved with growing configurations; for example, the assertion $\forall \x. [\ \x : \prg{Purse} \rightarrow \x.\prg{balance}>100\ ]$ may hold in a smaller configuration, but not hold in an extended configuration. Nor is it preserved with configuratio s getting smaller; consider \eg $\exists \x. [\ \x : \prg{Purse} \wedge \x.\prg{balance}>100\ ]$

% \begin{definition}
%We say that $\sigma \vdash \A$ if for any  \x\, is free in $\A$ and any
%  any term $\x.\f_1...\f_n$ appearing in $\A$,
% the interpretation $\interp{\x.\f_1...\f_n} \sigma$ is defined.
%\end{definition}
%
%Note that if we take $n=0$ in the definition above we obtain as corollary that   all variables that appear free in $\A$ they  are in the domain of the top frame in $\sigma$.
%
%\begin{lemma}[Preservation of satisfaction] $ $
%\label{lemma:preserve:valid}
%\begin{itemize}
%\item
%If  $\sigma \vdash \A$ and $\M\mkpair \M',  \sigma \vdash \A$ and   $\sigma' \subconf \sigma$, \  then  \ $\M\mkpair \M',  \sigma' \models \A$.
%\end{itemize}
%\end{lemma}

Finally, we define satisfaction of assertions by modules: A module $\M$ satisfies an assertion $\A$ if for all modules $\M'$, in all configurations arising from executions of $\M\mkpair\M'$, the assertion $\A$ holds.

\begin{definition}
\label{def:module_satisfies}
For any module $\M$, and  assertion $\A$, we define:
\begin{itemize}
\item
$\M \models \A$ \IFF  $\forall \M'.\, \forall \sigma\!\in\!\Arising{\M\mkpair\M'}.\   \M\mkpair\M', \sigma \models \A$
\end{itemize}
\end{definition}

