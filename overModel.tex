%\section{Overview of the \Chainmail\  formal model}
% \subsection{The Open World}

\sd{Having outlined the ingredients of our holistic specification language, the next question to ask is: When does a module 
$\M$ satisfy such a holistic assertion $\A$? In our notation, when does} \\
$~ \strut  \hspace{1.3in}\ \M \models \A$ \\
hold? 
   
\sd{Our  answer must reflect the fact that we are dealing with the 
\emph{open  world},  where  $\M$, our module, may be
linked with \textit{arbitrary untrusted code}. To reflect this}  we consider
 pairs of modules, 
$\M \mkpair {\M'}$,  where $\M$ is the module 
whose code is supposed to satisfy the assertion,
and $\M'$  is  another % wused to say \textit{any}  -- but why?
 module which exercises
the functionality of $\M$. We call $\M$ the {\em internal}, and $\M'$ is the {\em external} module.
%or {\em potentially adversarial} module. 
    
We can now answer our original question.  $\M \models \A$ 
  holds if for all further, {\em potentially adversarial}, modules $\M'$ and in  all runtime configurations $\sigma$ which may be observed through execution of the code of $\M$ combined with that of $\M'$, the assertion $\A$ is satisfied. More formally, we define:\\
$~ \strut  \hspace{1.3in} \M \models \A \ \ \  \ \ \ \ \ \mbox{
if               } \ \ \  \ \ \  \  \forall \sigma\in\Arising
{\M \mkpair  {\M'}}. [\ \M \mkpair  {\M'},\sigma \models \A\ ]$.  \\
In that sense, module $\M'$ represents all possible clients of {\M}; and as it is arbitrarily chosen, it reflects the open world nature of our specifications.%\sdcomment
\sophia{James had said to keep that sentence, but now that I reworked 
the above, perhaps it is superfluous.}

The assertion $\M \mkpair  {\M'},\sigma \models \A$ means that the runtime configuration $\sigma$ satisfies the 
assertion $\A$. \sd{In contrast to traditional specification languages \cite{jml,Eiffel}, satisfaction has to be judged 
in the context of a module pair, here $\M \mkpair  {\M'}$.
We need the modules, because our assertions may 
talk about the future. In order to be able to talk about the future we need to have access to the
method bodies defined in these modules. We} also need to distinguish between  the internal and the external module,
because when examining program executions, we are only interested
 in those runtime configurations which are {\em external} to module $\M$, \ie those where the
 executing object (\ie the current receiver) comes from module $\M'$. 

\sd{Similarly, when considering $\Arising {\M \mkpair  {\M'}}$, \ie the configurations arising from 
executions in $\M \mkpair  {\M'}$, we can take method bodies defined in $\M$ or in $\M'$, but we will only consider the runtime 
configurations which are external to $\M$.
}
\sd{Therefore, the pair $\M \mkpair  {\M'}$ is different than the concatenation of the two modules}
In  that sense, our approach is similar to that of visible states semantics, without, however the need to consider issues
around different objects of the same class or re-entrancy.\footnote{TODO: add references here.}

